[{"path":"/architecture.html","id":null,"dir":"","previous_headings":"","what":"Architecture","title":"Architecture","text":"Lifecycle emr_extract call: Start NRExtract.cpp. Create NRTrackExprScanner object computation. NRTrackExpressionScanner (scanner short) class generates iterators, .e. begin, next isend methods used simple loop form (following pseudu code): parameters scanner gets begin function one emr_extract call: expressions, stime, etime, iterator, keepref filter.","code":"for (scanner.begin(parameters); !scanner.isend(); scanner.next()) {     # get the values      values_output = scanner.real();     points_output = scanner.point();          # check that we did not exceed the maximal data size }"},{"path":[]},{"path":"/architecture.html","id":"the-begin-method","dir":"","previous_headings":"Inside the scanner","what":"The begin method:","title":"Architecture","text":"Converts expressions strings stime etime unsigned keepref logical. Runs check method (see ) creates tracks, vtracks iterator objects. Creates R variables tracks virtual tracks (define_r_vars scanner NRTrackExpressionVars) reserves eval_buf_limit results m_expr_itr_points m_eval_doubles. “Determining evaluation buffer size”. sure exactly works yet.","code":""},{"path":"/architecture.html","id":"the-check-method","dir":"","previous_headings":"Inside the scanner","what":"The check method:","title":"Architecture","text":"checks validity expressions. Adds m_expr_vars virtual tracks tracks using parse_exprs. Tracks added getting EMRTrack object g_db EMRDb object. Virtual tracks added parsing parameters getting needed source track g_db. case dataframe intermediate track created. virtual track filter - intermediate track created applies filter source track. creates iterator (create_expr_iterator): iterator argument number - iterator pointer (m_itr) gets new EMRBeatIterator string - EMRTrackIterator. Parse expressions (using R) put result m_eval_exprs","code":""},{"path":"/architecture.html","id":"the-next-method","dir":"","previous_headings":"Inside the scanner","what":"The next method:","title":"Architecture","text":"Calls (multitasking) eval_next: Asks current iterator current point. calls set_vars method NRTrackExprVars (m_expr_vars) given point iterator fetches data using variable data fetcher. Evaluates expression using R fetched data (now new R variable). Ask iterator next point (m_itr.next()) magic finding next point (filtering) inside iterator!","code":""},{"path":"/architecture.html","id":"filter-on-vtrack-proposal","dir":"","previous_headings":"","what":"Filter on vtrack proposal","title":"Architecture","text":"can parse filters, whenever source vtrack, collect expression. , can: Run collected expressions together query iterator (’s filters without vtracks) Create temporary tracks results. Change vtrack filters existence tracks. Run original query. create new type filter returns either always TRUE FALSE. parsing filter expression tree replace every vtrack filter operator “” FALSE operator “” TRUE. keep vector pointers filters, vtrack names sources. , scan vtrack expressions vtrack filters effectivly ignored. new data frame able create new filters use replace ones “inert” TRUE FALSE.","code":""},{"path":"/architecture.html","id":"keepref-on-vtracks","dir":"","previous_headings":"","what":"Keepref on vtracks","title":"Architecture","text":"line 122 NRTrackExpressionVars: iimanager->transform(point, iimanager->keepref ? point.timestamp.refcount() : EMRTimeStamp::NA_REFCOUNT);","code":""},{"path":"/articles/naryn.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"naryn","text":"Naryn allows efficient access analysis medical records maintained custom database. Naryn can work R (package) Python (module). vast majority functions concepts shared two implementations, yet certain differences still exist summarized table . Code examples function names document presented R can equally run Python interface changes table.","code":""},{"path":[]},{"path":"/articles/naryn.html","id":"global-and-user-space-read-only-tracks","dir":"Articles","previous_headings":"Database","what":"Global and User Space, Read-Only Tracks","title":"naryn","text":"Naryn allows accessing data resides tracks track holds certain type medical data patients' diagnoses hemoglobin level certain points time. track files aggregated directory. tracks can accessed, Naryn needs establish connection directory, also referred global root global space root. Call emr_db.init function establish access tracks global root directory. Optionally emr_db.init accepts additional user root (user space root) directory can also constains additional tracks. Even though global user root directories may contain track files designation different. global root directory intended stay mainly read-. user root directory hand intended store volatile data like results intermediate calculations. New tracks can created user global space using emr_track.import emr_track.create yet creation tracks global space done well justified reason. track may marked read-prevent accidential deletion modification. Use emr_track.readonly set get read-property track. newly created tracks always writable. wish mark \"read-\", please separate call.","code":""},{"path":"/articles/naryn.html","id":"load-on-demand-vs--pre-load-modes","dir":"Articles","previous_headings":"Database","what":"Load-on-demand vs. Pre-load Modes","title":"naryn","text":"emr_db.init supports two modes work - 'load demand' 'pre-load'. 'load demand' mode tracks loaded memory accessed. Tracks stay memory R sessions ends package unloaded (Python: since modules forced unload, db_unload introduced). 'pre-load' mode, tracks pre-loaded memory making subsequent track access significantly faster. loaded tracks reside shared memory, R sessions running machine may also enjoy significant run-time boost. flip side, pre-loading tracks prolongs execution emr_db.init requires enough memory accommodate data. Choosing two modes depends specific needs. load..demand=TRUE seems solid default choice, environment frequent short-living R sessions, accessing track, one might opt running \"daemon\" - additional permanent R session. daemon pre-load tracks advance stay alive thus boosting run-time later emerging sessions.","code":""},{"path":"/articles/naryn.html","id":"maintaining-database","dir":"Articles","previous_headings":"Database","what":"Maintaining Database","title":"naryn","text":"Naryn caches certain data disk maintain fast run-times. particular two files (.naryn .ids) created global root directory one file (.ids}) user root directory. .naryn file contains list tracks current root directory last modification dates. file spares full root directory rescan emr_db.init called. recorded modification dates allow efficiently synchronize track changes induced synchronically running R sessions. .ids file contains available ids used run certain types track expression iterators (see ). source ids comes `patients.dob} (.e. Date Birth) track, must present global root directory iterators may utilized. Various functions emr_track.import modify files according changes DB undergoes (addition / removal / modification tracks). Thus manual (outside Naryn) modification, replacement, addition deletion track files cause cache files go sync. Various problems might arise consequence, run-time errors, -dated data modified tracks sub-optimal run-time performance. Manual modifications database files can still performed, yet must ratified running emr_db.reload.","code":""},{"path":"/articles/naryn.html","id":"tracks","dir":"Articles","previous_headings":"Database","what":"Tracks","title":"naryn","text":"track stored binary file .nrtrack file extention. One two internal formats, dense sparse, automatically selected track creation. choice exact format based optimal run-time performance.","code":""},{"path":"/articles/naryn.html","id":"records-and-references","dir":"Articles","previous_headings":"Database > Tracks","what":"Records and References","title":"naryn","text":"Track data structure stores set records (id, time, ref, numeric value) type. example, hemoglobin level patients can stored way, id id patient time indicate moment blood test made. Another track can contain code laboratory carried test. times records two tracks match, one conclude lab performed given test. Time resolution always hours. might happen two different blood tests carried two different labs patient hour. Assuming lab certain bias due different equipment used, reads hemoglobin might come different. Since tests carried exactly hour impossible later link result lab performed . cases two values share identical id time Naryn requires use different ref (references). reference integer number range [-1, 254], time collision occurs normally set -1. However, cases ambiguity can give additional resolution time. blood example results first lab recorded ref = 0 second lab ref = 1. way two hemoglobin readings later separated correctly linked originating labs.","code":""},{"path":"/articles/naryn.html","id":"categorical-and-quantitative-tracks","dir":"Articles","previous_headings":"Database > Tracks","what":"Categorical and Quantitative Tracks","title":"naryn","text":"Tracks store numerical values assigned patients times. numerical data however can different meaning hence impose different set operations applied . Laboratory codes, diagnosis codes, binary information date birth doctor visits one type data call categorical. Another type data indicate usually readings different instruments heartbeat rate glucose level. type data called quantitative. operations can applied types can different. One might want search specific diagnosis code, yet makes little sense search specific heartbeat rate, say \"68\". contrary hearbeat rate readings different times can averaged mean value might calculated - something meaning case categorical data. track creation one must specify type track: categorical quantitative. Various operations can later applied track bound track type.","code":""},{"path":"/articles/naryn.html","id":"logical-tracks","dir":"Articles","previous_headings":"Database > Tracks","what":"Logical tracks","title":"naryn","text":"addition physical tracks stored binary files, naryn supports concept logical track alias physical track. example, assume track called lab.103 contains hemoglobin levels patients. convenient refer explicitly hemoglobin instead remembering lab code. Logical tracks exactly , can create logical track called hemoglobin refers physical lab.103: can also use logical tracks create alias specific values categorical track. example, suppose track called diagnosis.250 contains diagnosis times ICD code 250 (\"250.*\"), values sub-diagnosis (e.g. 1 250.1 4 250.4). Logical tracks allow us create alias specific sub-diagnosis value refer regular track: hood logical tracks implemented using virtual tracks mechanism (see ), unlike virtual tracks - part database persistent sessions. can delete logical track calling emr_track.logical.rm list using emr_track.logical.ls.","code":"emr_track.logical.create(\"hemoglobin\", \"lab.103\") emr_extract(\"hemoglobin\") emr_track.logical.create(\"dx.250.1_4\", \"diagnosis.250\", values = c(1,4)) emr_extract(\"dx.250.1_4\")"},{"path":"/articles/naryn.html","id":"track-attributes","dir":"Articles","previous_headings":"Database > Tracks","what":"Track Attributes","title":"naryn","text":"addition numeric data track may store arbitrary meta-data description, source, etc. meta-data stored form name-value pairs attributes value character string. Though officially enforced attributes intended store relatively short character strings. Please use track variables store data format. single attribute can retrieved, added, modified deleted using emr_track.attr.get emr_track.attr.set functions. Bulk access one attribute facilitated emr_track.attr.export function. Track names attributes values match pattern can retrieved using emr_track.ls, emr_track.global.ls emr_track.user.ls functions.","code":""},{"path":"/articles/naryn.html","id":"track-variables","dir":"Articles","previous_headings":"Database > Tracks","what":"Track Variables","title":"naryn","text":"Track statistics, results time-consuming per-track calculations, historical data data arbitrary format can stored track's supplementary data form track variables. Track variable can retrieved, added, modified deleted using emr_track.var.get, emr_track.var.set emr_track.var.rm functions. List track variables can retrieved using emr_track.var.ls function. Note: track variables created R visible Python vice versa.","code":""},{"path":"/articles/naryn.html","id":"track-attributes-vs--track-variables","dir":"Articles","previous_headings":"Database > Tracks","what":"Track Attributes vs. Track Variables","title":"naryn","text":"Though track attributes track variables can used store meta-data track, important differences two summed following table:","code":""},{"path":"/articles/naryn.html","id":"subsets","dir":"Articles","previous_headings":"Database > Tracks","what":"Subsets","title":"naryn","text":"analysis data often involves dividing data train test sets. Naryn allows subset data via emr_db.subset function. emr_db.subset accepts list ids samples ids randomally. ids constitute subset. ids subset skipped iterators, filters various functions. One may think subset additonal layer, \"viewport\", filters ids. lower-level functions emr_track.info emr_track.unique ignore subsets. applies percentile.* functions virtual tracks.","code":""},{"path":[]},{"path":[]},{"path":"/articles/naryn.html","id":"introduction-1","dir":"Articles","previous_headings":"Accessing the Data > Track Expressions","what":"Introduction","title":"naryn","text":"Track expression allows retrieve numerical data recorded tracks. Track expressions widely used various functions (emr_screen, emr_extract, emr_dist, ...). Track expression character string closely resembles valid R/Python expression. Just like R/Python expression may include conditions, function calls variables defined beforehand. \"1 > 2\", \"mean(1:10)\" \"myvar < 17\" valid track expressions. Unlike regular R/Python expressions track expression might also contain track names / virtual track names. understand track expression allows access tracks must explain track expression gets evaluated. Every track expression accompanied iterator produces set id-time points (id, time, ref) type. iterator point track expression evaluated. value track expression \"mean(1:10)\" constant regardless iterator point. However track expression might contain track name mytrack, like: \"mytrack * 3\". Naryn recognizes mytrack regular R/Python variable rather track name. new run-time track variable named mytrack added R environment (Python module local dictionary). iterator point variable assigned value track matches (id, time, ref) (NaN matching value exists track). mytrack assigned corresponding value, track expression evaluated R/Python.","code":""},{"path":"/articles/naryn.html","id":"run-time-track-variable-is-a-vector","dir":"Articles","previous_headings":"Accessing the Data > Track Expressions","what":"Run-time Track Variable is a Vector","title":"naryn","text":"boost performance track expression evaluation, run-time track variables actually defined vectors R rather scalars. result evaluation expected also vector similar size. One always keep mind vectorial notation write track expressions accordingly. example, first glance track expression \"min(mytrack, 10)\" seems perfectly fine. However evaluation expression produces always scalar, .e. signle number even mytrack actually vector. way correct specific track expression works vectors, use pmin function instead min. Python Similarly R, track variable Python scalar rather instance numpy.ndarray. evaluation track expression must therefore produce numpy.ndarray well. Various operations numpy arrays indeed work way scalars, however logical operations require different syntax. instance: produce error given mytrack1 mytrack2 numpy arrays. correct way write expression : One may coerce track variable behave like scalar: setting emr_eval.buf.size option 1 (see Appendix details). Beware though might take heavy toll run-time.","code":"screen(\"mytrack1 > 1 and mytrack2 < 2\", iterator = \"mytrack1\") screen(\"(mytrack1 > 1) & (mytrack2 < 2)\", iterator=\"mytrack1\")"},{"path":"/articles/naryn.html","id":"matching-reference-in-the-track-expression","dir":"Articles","previous_headings":"Accessing the Data > Track Expressions","what":"Matching Reference in the Track Expression","title":"naryn","text":"track expression contains track (virtual track) name, values track fetched one--one identically named R variable based id, time ref iterator point. however ref iterator point equals -1, treat \"wildcard\": matching required id time. \"Wildcard\" reference iterator might create new issue: one track value might match single iterator point. case value placed track variable (e.g. mytrack) depends type track. track categorical track variable set -1, otherwise set average matching values.","code":""},{"path":"/articles/naryn.html","id":"virtual-tracks","dir":"Articles","previous_headings":"Accessing the Data > Track Expressions","what":"Virtual Tracks","title":"naryn","text":"far shown situations mytrack variable can set average matching track values. want average values rather pick maximal, minimal median value? want use percentile track value rather value ? maybe even want alter time iterator point: shift expand time window look different set track values? instance: given iterator point might want know maximal level glucose last year preceeded time point. virtual tracks come use. Virtual track named set rules describe track proceeded, time iterator point modified. Virtual tracks created emr_vtrack.create function: call creates new virtual track named annual_glucose based underlying physical source track glucose_track. iterator point time T look values glucose_track time window [T-365*24,T], .e. one year prior T. calculate median values (func=\"quantile\", param=0.5). rich set various functions besides \"quantile\" can applied track values. functions can used categorical tracks, ones - quantitative tracks functions can applied types track. Please refer documentation emr_vtrack.create. virtual track created can used track expression: give us median annual glucose level year-steps starting patient's birthday. (example makes use Extended Beat Iterator expalained later.) expand example ignore calculations glucose readings made within week steroids prescribed. can use additional filter parameter . Filter applied ID-Time points source track (e.g. glucose_track example). virtual track function (quantile, ...) applied points pass filter. concept filters explained extensively separate chapter. Virtual tracks allow also remap patient ids. done via id.map parameter accepts data frame defines id mapping. Remapping ids might useful family ties explored. example, instead glucose level patient interested check glucose level one family members.","code":"emr_vtrack.create(\"annual_glucose\",   src = \"glucose_track\", func = \"quantile\",   param = 0.5, time.shift = c(-year(), 0) ) emr_extract(\"annual_glucose\", iterator = list(year(), \"patients.dob\")) emr_filter.create(\"steroids_filter\", \"steroids_track\", time.shift=c(-week(), 0)) emr_vtrack.create(\"annual_glucose\",   src = \"glucose_track\", func = \"quantile\",   param = 0.5, time.shift = c(-year(), 0), filter = \"!steroids_filter\" ) emr_extract(\"annual_glucose\", iterator = list(year(), \"date_of_birth_track\"))"},{"path":"/articles/naryn.html","id":"iterators","dir":"Articles","previous_headings":"Accessing the Data","what":"Iterators","title":"naryn","text":"far discussed track expressions evaluated given iterator point. section show iterator points generated. iterator defined via iterator parameter. types iterators track iterator, beat iterator, etc. type determines points generated iterator. information type listed . Iterator always accompanied four additional parameters: stime, etime, keepref filter. stime etime bind time scope iterator: points iterator generates lie always within boundaries. effect keepref=TRUE depends iterator type. However iterator types keepref=FALSE reference iterator points set -1. filter parameter sets iterator filter discussed thoroughly later document separate chapter.","code":""},{"path":"/articles/naryn.html","id":"track-iterator","dir":"Articles","previous_headings":"Accessing the Data > Iterators","what":"Track Iterator","title":"naryn","text":"Track iterator returns points (including reference) specified track. Track name specified string. keepref=FALSE reference point set -1. Example:","code":"# Returns the level of glucose one hour after the insulin shot was made emr_vtrack.create(\"glucose\", \"glucose_track\", func=\"avg\", time.shift=1) emr_extract(\"glucose\", iterator=\"insulin_shot_track\")"},{"path":"/articles/naryn.html","id":"id-time-points-iterator","dir":"Articles","previous_headings":"Accessing the Data > Iterators","what":"Id-Time Points Iterator","title":"naryn","text":"Id-Time points iterator generates points id-time points table (see: Appendix). keepref=FALSE reference point set -1. Example:","code":"# Returns the level of glucose one hour after the insulin shot was made emr_vtrack.create(\"glucose\", \"glucose_track\", func=\"avg\", time.shift=1) r <- emr_extract(\"insulin_shot_track\")  # <-- implicit iterator is used here emr_extract(\"glucose\", iterator=r)"},{"path":"/articles/naryn.html","id":"ids-iterator","dir":"Articles","previous_headings":"Accessing the Data > Iterators","what":"Ids Iterator","title":"naryn","text":"Ids iterator generates points ids taken ids table (see: Appendix) times run stime etime step 1. keepref=TRUE id-time pair iterator generates 255 points references running 0 254. keepref=FALSE one point generated given id time, reference set -1. Example:","code":"# Returns the level of glucose for each hour in year 2016 for ids 2 and 5 stime <- emr_date2time(1, 1, 2016, 0) etime <- emr_date2time(31, 12, 2016, 23) emr_extract(\"glucose\", iterator=data.frame(id=c(2,5)), stime=stime, etime=etime)"},{"path":"/articles/naryn.html","id":"time-intervals-iterator","dir":"Articles","previous_headings":"Accessing the Data > Iterators","what":"Time Intervals Iterator","title":"naryn","text":"Time intervals iterator generates points ids appear 'patients.dob' track times taken time intervals table (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside [stime, etime] range skipped. keepref=TRUE id-time pair iterator generates 255 points references running 0 254. keepref=FALSE one point generated given id time, reference set -1. Example:","code":"# Returns the level of hangover for all patients the next day after New Year Eve # for the years 2015 and 2016 stime1 <- emr_date2time(1, 1, 2015, 0) etime1 <- emr_date2time(1, 1, 2015, 23) stime2 <- emr_date2time(1, 1, 2016, 0) etime2 <- emr_date2time(1, 1, 2016, 23) emr_extract(\"alcohol_level_track\", iterator=data.frame(stime=c(stime1, stime2),             etime=c(etime1, etime2)))"},{"path":"/articles/naryn.html","id":"id-time-intervals-iterator","dir":"Articles","previous_headings":"Accessing the Data > Iterators","what":"Id-Time Intervals Iterator","title":"naryn","text":"Id-Time intervals iterator generates id points cover ['stime', 'etime'] time range specified id-time intervals table (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside [stime, etime] range skipped. keepref=TRUE id-time pair iterator generates 255 points references running 0 254. keepref=FALSE one point generated given id time, reference set -1.","code":""},{"path":"/articles/naryn.html","id":"beat-iterator","dir":"Articles","previous_headings":"Accessing the Data > Iterators","what":"Beat Iterator","title":"naryn","text":"Beat Iterator generates \"time beat\" given period id appear 'patients.dob' track. period given always hours. Example: create beat iterator period 10 hours starting stime etime reached. , example, stime equals 1000 beat iterator create id iterator points times: 1000, 1010, 1020, ... keepref=TRUE id-time pair iterator generates 255 points references running 0 254. keepref=FALSE one point generated given id time, reference set -1.","code":"emr_extract(\"glucose_track\", iterator=10, stime=1000, etime=2000)"},{"path":"/articles/naryn.html","id":"extended-beat-iterator","dir":"Articles","previous_headings":"Accessing the Data > Iterators","what":"Extended Beat Iterator","title":"naryn","text":"Extended beat iterator name suggests variation beat iterator. works principle creating time points given period however instead basing times count stime accepts additional parameter - track Id-Time Points table - instructs initial time point ids. two parameters (period mapping) come list. id required appear certain id appear , skipped iterator. Anyhow points lie outside [stime, etime] range generated. Example:","code":"# Returns the maximal weight of patients at one year span starting from their birthdays emr_vtrack.create(\"weight\", \"weight_track\", func = \"max\", time.shift = c(0, year())) emr_extract(\"weight\", iterator = list(year(), \"birthday_track\"), stime = 1000, etime = 2000)"},{"path":"/articles/naryn.html","id":"periodic-iterator","dir":"Articles","previous_headings":"Accessing the Data > Iterators","what":"Periodic Iterator","title":"naryn","text":"periodic iterator goes every year/month. can use running emr_monthly_iterator emr_yearly_iterator. Example:","code":"iter <- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017)) emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3) iter <- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15) emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)"},{"path":"/articles/naryn.html","id":"implicit-iterator","dir":"Articles","previous_headings":"Accessing the Data > Iterators","what":"Implicit Iterator","title":"naryn","text":"iterator set implicitly value remains NULL (default). case track expression analyzed searched track names. track variables virtual track variables point track, track used source track iterator. one track appears track expression, error message printed notifying ambiguity.","code":""},{"path":"/articles/naryn.html","id":"revealing-current-iterator-time","dir":"Articles","previous_headings":"Accessing the Data > Iterators","what":"Revealing Current Iterator Time","title":"naryn","text":"evaluation track expression one can access specially defined variable named EMR_TIME (Python: TIME). variable contains vector (numpy.ndarray Python) current iterator times. length vector matches length track variable (vector ). Note values EMR_TIME might set 0. Skip intervals values track variables corresponding indices.","code":"# Returns times of the current iterator as a day of month emr_extract(\"emr_time2dayofmonth(EMR_TIME)\", iterator = \"sparse_track\")"},{"path":"/articles/naryn.html","id":"filters","dir":"Articles","previous_headings":"Accessing the Data","what":"Filters","title":"naryn","text":"Filter used approve / reject ID-Time point. can applied iterator, case iterator points required approved filter passed track expression. Filter may also used virtual track. case virtual track function (see func parameter emr_vitrack.create) applied points source track (src parameter) pass filter. Filter form logical expression consisting named unnamed elementary filters (\"building bricks\" filter) connected logical operators: &, |, ! (, Python) brackets ().","code":""},{"path":"/articles/naryn.html","id":"named-filters","dir":"Articles","previous_headings":"Accessing the Data > Filters","what":"Named Filters","title":"naryn","text":"Suppose interested hemoglobin levels patients prescribed either drugX drugY drugZ within time window one week test. Assume drugX, drugY drugZ residing separate track. Without filters need call emr_extract four times, store potentially huge data frame results memory finally merge tables within R caring time windows. filters can much easier: Python Filter logical conditions use Python's notation like: call emr_filter.create creates named elementary filter (simply: named filter) unique name. named filter can used filter parameter iterator combined named filters using logical operators.","code":"emr_filter.create(\"filterX\", \"drugX\", time.shift = c(week(), 0)) emr_filter.create(\"filterY\", \"drugY\", time.shift = c(week(), 0)) emr_filter.create(\"filterZ\", \"drugZ\", time.shift = c(week(), 0)) emr_extract(\"hemoglobin\", filter = \"(filterX | filterY) & !filterZ\") extract(\"hemoglobin\", filter = \"(filterX or filterY) and not filterZ\")"},{"path":"/articles/naryn.html","id":"other-objects-within-filters","dir":"Articles","previous_headings":"Accessing the Data > Filters","what":"Other Objects within Filters","title":"naryn","text":"previous example created three named filters based three tracks. time window required, used names tracks directly filter, like: filter = \"(drugX | drugY) & !drugZ\". addition track names types objects can used within filter. : Id-Time Points Table, Ids Table, Time Intervals Table Id-Time Intervals Table (see Appendix format tables). used filter object constructed advanced referred name. \"place\" construction (aka: filter = \"data.frame(...)\" allowed.","code":""},{"path":"/articles/naryn.html","id":"managing-reference-in-filters","dir":"Articles","previous_headings":"Accessing the Data > Filters","what":"Managing Reference in Filters","title":"naryn","text":"ID-Time Point embeds within reference value. Named filters allow specify whether reference used matching . keepref=TRUE set within emr_filter.create, candidate point's reference matched filter's reference. Otherwise references ignored. important remember references always ignored object named filter used within filter. instance, filter = \"drug\" drug name track (name named filter), references ignored matching. ensure filter matches references drug track, one must define named filter keepref=TRUE parameter:","code":"emr_filter.create(\"drug_filter\", \"drug\", keepref=TRUE) emr_extract(my.track.expression, filter=\"drug_filter\", keepref=TRUE)"},{"path":[]},{"path":"/articles/naryn.html","id":"random-algorithms","dir":"Articles","previous_headings":"Advanced Naryn","what":"Random Algorithms","title":"naryn","text":"Various functions library emr_quantiles make use pseudo-random number generator. time function invoked unique series random numbers issued. Hence two identical calls might produce different results. guarantee reproducible results call set.seed (Python: texttt{seed`) invoking function. Note: R Python implementations Naryn use different pseudo-random number generator algorithms. Sadly means result achieved R reproducible Python random used, even identical seed shared two platforms.","code":""},{"path":"/articles/naryn.html","id":"multitasking","dir":"Articles","previous_headings":"Advanced Naryn","what":"Multitasking","title":"naryn","text":"boost run time performance various functions library support multitasking mode, .e. parallel computation several concurrent processes. Multitasking invoked immediately: approximately 0.3 seconds function launch actual progress measured total run-time estimated. estimated run-time exceeds limit (currently: 2 seconds), multitasking kicks . number processes launched multitasking mode depends total run-time estimation (longer run-time use processes) values emr_min.processes emr_max.processes R options. case number processes never exceeds number CPU cores available. Multitasking can significantly boost performance however utilizes CPU. CPU utilization priority advisable switch multitasking setting emr_multitasking R option FALSE. addition increased CPU usage multitasking might also alter behavior functions return ID-Time points emr_extract emr_screen. multitasking invoked functions return results always sorted ID, time reference. multitasking mode however result might come unsorted. Moreover subsequent calls might return results reshuffled differently. One might use sort parameter functions ensure points come sorted. Please bear mind sorting results takes toll especially particularly large data frames. default sort set FALSE.","code":""},{"path":[]},{"path":[]},{"path":"/articles/naryn.html","id":"options","dir":"Articles","previous_headings":"Appendix","what":"Options","title":"naryn","text":"Naryn supports following options. options can set/examined via R's options getOption. (Use CONFIG['option_name'] control module options Python. Please mind well Python's name convention: R's emr_xxx.yyy option change name xxx_yyy.)","code":""},{"path":[]},{"path":"/articles/naryn.html","id":"id-time-points-table","dir":"Articles","previous_headings":"Appendix","what":"Id-Time Points Table","title":"naryn","text":"Id-Time Points table data frame two first columns named 'id' 'time'. References might specified third column named 'ref'. 'ref' column missing named differently references set -1. Additional columns, presented, ignored.","code":""},{"path":"/articles/naryn.html","id":"id-time-values-table","dir":"Articles","previous_headings":"Appendix","what":"Id-Time Values Table","title":"naryn","text":"Id-Time Values table extension Id-Time Points table additional column named 'value'. Additional columns, presented, ignored.","code":""},{"path":"/articles/naryn.html","id":"ids-table","dir":"Articles","previous_headings":"Appendix","what":"Ids Table","title":"naryn","text":"Ids table data frame first column named 'id'. id must appear . Additional columns data frame, presented, ignored.","code":""},{"path":"/articles/naryn.html","id":"time-intervals-table","dir":"Articles","previous_headings":"Appendix","what":"Time Intervals Table","title":"naryn","text":"Time Intervals table data frame two first columns named 'stime' 'etime' (.e. start time end time). Additional columns, presented, ignored.","code":""},{"path":"/articles/naryn.html","id":"id-time-intervals-table","dir":"Articles","previous_headings":"Appendix","what":"Id-Time Intervals Table","title":"naryn","text":"Id-Time Intervals table data frame three first columns named 'id', 'stime' 'etime' (.e. start time end time). Additional columns, presented, ignored.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Misha Hoichman. Author, maintainer. Aviezer Lifshitz. Author. Ben Gilat. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hoichman M, Lifshitz , Gilat B (2021). naryn: Toolkit analysis medical records. R package version 2.6.1.","code":"@Manual{,   title = {naryn: Toolkit for analysis of medical records},   author = {Misha Hoichman and Aviezer Lifshitz and Ben Gilat},   year = {2021},   note = {R package version 2.6.1}, }"},{"path":"/index.html","id":"naryn","dir":"","previous_headings":"","what":"Toolkit for analysis of medical records","title":"Toolkit for analysis of medical records","text":"‘naryn’ package helps efficiently analyze medical records data.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Toolkit for analysis of medical records","text":"","code":"remotes::install_github(\"tanaylab/naryn\")"},{"path":"/reference/emr_annotate.html","id":null,"dir":"Reference","previous_headings":"","what":"Annotates id-time points table — emr_annotate","title":"Annotates id-time points table — emr_annotate","text":"Annotates id-time points table values given second table.","code":""},{"path":"/reference/emr_annotate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Annotates id-time points table — emr_annotate","text":"","code":"emr_annotate(x, y)"},{"path":"/reference/emr_annotate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Annotates id-time points table — emr_annotate","text":"x sorted id-time points table expanded y sorted id-time points table used annotations","code":""},{"path":"/reference/emr_annotate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Annotates id-time points table — emr_annotate","text":"data frame columns 'x' additional columns 'y'.","code":""},{"path":"/reference/emr_annotate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Annotates id-time points table — emr_annotate","text":"function merges two sorted id-time points tables 'x' 'y' matching 'id', 'time' 'ref' columns. result new id-time points table additional columns 'x' 'y'. Two rows match 'id' 'time' match either 'ref' matches one 'ref' '-1'. row RX 'x' matches N rows RY1, ..., RYn 'y', N rows added result: [RX RY1], ..., [RX RYn]. row RX 'x' match rows 'y', row [RX NA] form added result (.e. values columns borrowed 'y' set 'NA'). missing 'ref' column interpreted reference equals '-1'. 'x' 'y' must sorted 'id', 'time' 'ref' (order!). Note however package functions ('emr_extract', ...) return id-time point tables always properly sorted.","code":""},{"path":[]},{"path":"/reference/emr_annotate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Annotates id-time points table — emr_annotate","text":"","code":"emr_db.init_examples()  r1 <- emr_extract(\"sparse_track\", keepref = T) r2 <- emr_extract(\"dense_track\", keepref = T) r2$dense_track <- r2$dense_track + 1000 emr_annotate(r1, r2) #>    id time ref sparse_track dense_track #> 1   5    1   3           13          NA #> 2  10    1   3           13          NA #> 3  25    1   0           10        1010 #> 4  25    2   0           20        1020 #> 5  25    2   2           22        1022 #> 6  25    2   4           24          NA #> 7  25    2   6           26        1026 #> 8  25    2   8           28        1028 #> 9  25    3   4           34        1034 #> 10 25    6   0           60        1060 #> 11 25    6   2           62        1062 #> 12 25    8   1           80        1080 #> 13 25    8   4           84        1084 #> 14 25    9   2           92        1092 #> 15 25    9   4           94        1094 #> 16 25   10   4          104        1104 #> 17 25   12   4          124        1124 #> 18 27   23   4          234        1234 #> 19 33   23   4          234          NA #> 20 33   50   0          500          NA #> 21 40    1   3           13          NA"},{"path":"/reference/emr_cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates correlation statistics for pairs of track expressions — emr_cor","title":"Calculates correlation statistics for pairs of track expressions — emr_cor","text":"Calculates correlation statistics pairs track expressions.","code":""},{"path":"/reference/emr_cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates correlation statistics for pairs of track expressions — emr_cor","text":"","code":"emr_cor(   ...,   cor.exprs = NULL,   include.lowest = FALSE,   right = TRUE,   stime = NULL,   etime = NULL,   iterator = NULL,   keepref = F,   filter = NULL,   dataframe = FALSE,   names = NULL )"},{"path":"/reference/emr_cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates correlation statistics for pairs of track expressions — emr_cor","text":"cor.exprs vector track expressions correlation statistics calculated. include.lowest 'TRUE', lowest (highest, ‘right = FALSE’) value range determined breaks included. right 'TRUE' intervals closed right (open left), otherwise vice versa. stime start time scope. etime end time scope. iterator track expression iterator. 'NULL' iterator determined implicitly based track expressions. See also 'iterator' section. keepref 'TRUE' references preserved iterator. filter Iterator filter. dataframe return data frame instead N-dimensional vector. names names track expressions returned dataframe (relevant dataframe == TRUE) expr track expression. breaks breaks determine bin 'NULL'.","code":""},{"path":"/reference/emr_cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates correlation statistics for pairs of track expressions — emr_cor","text":"list 5 elements containing N-dimensional vector (N number 'expr'-'breaks' pairs). member vector specific statistics matrix. dataframe == TRUE - data frame column track expression, additional columns ,j pairs cor_exprs another 5 columns: 'n', 'e', 'var', 'cov', 'cor', see description.","code":""},{"path":"/reference/emr_cor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates correlation statistics for pairs of track expressions — emr_cor","text":"function works similar manner 'emr_dist'. However instead returning single counter bin 'emr_cor' returns 5 matrices 'length(cor.exprs) X length(cor.exprs)' size. matrix represents correlation statistics pair track expressions 'cor.exprs'. Given 'bin' pair track expressions 'cor.exprs[]' 'cor.exprs[j]' corresponding matrix contains following information: $n[bin,,j] - number times 'cor.exprs[]' 'cor.exprs[j]' exist $e[bin,,j] - expectation (average) values 'cor.exprs[]' 'cor.exprs[j]' exists $var[bin,,j] - variance values 'cor.exprs[]' 'cor.exprs[j]' exists $cov[bin,,j] - covariance 'cor.exprs[]' 'cor.exprs[j]' $cor[bin,,j] - correlation 'cor.exprs[]' 'cor.exprs[j]' Similarly 'emr_dist' 'emr_cor' can multi-dimensional binning. Given N dimensional binning individual data matrices can accessed : $cor[bin1, ..., binN, , j]. dataframe = TRUE return value data frame column track expression, additional columns ,j pairs cor_exprs another 5 columns: 'n', 'e', 'var', 'cov', 'cor' values matrices described .","code":""},{"path":"/reference/emr_cor.html","id":"iterator","dir":"Reference","previous_headings":"","what":"iterator","title":"Calculates correlation statistics for pairs of track expressions — emr_cor","text":"types iterators: Track iterator: Track iterator returns points (including reference) specified track. Track name specified string. `keepref=FALSE` reference point set `-1`  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func=\"avg\", time.shift=1)  emr_extract(\"glucose\", iterator=\"insulin_shot_track\") Id-Time Points Iterator: Id-Time points iterator generates points *id-time points table*. `keepref=FALSE` reference point set `-1`.  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func = \"avg\", time.shift = 1)  r <- emr_extract(\"insulin_shot_track\") # <-- implicit iterator used  emr_extract(\"glucose\", iterator = r) Ids Iterator: Ids iterator generates points ids taken *ids table* times run `stime` `etime` step 1. `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Example:  stime <- emr_date2time(1, 1, 2016, 0)  etime <- emr_date2time(31, 12, 2016, 23)  emr_extract(\"glucose\", iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime) Time Intervals Iterator: *Time intervals iterator* generates points ids appear 'patients.dob' track times taken *time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`.  Example:  # Returns level hangover patients next day New Year Eve years 2015 2016  stime1 <- emr_date2time(1, 1, 2015, 0)  etime1 <- emr_date2time(1, 1, 2015, 23)  stime2 <- emr_date2time(1, 1, 2016, 0)  etime2 <- emr_date2time(1, 1, 2016, 23)  emr_extract(\"alcohol_level_track\", iterator = data.frame(      stime = c(stime1, stime2),      etime = c(etime1, etime2)  )) Id-Time Intervals Iterator: *Id-Time intervals iterator* generates id points cover `['stime', 'etime']` time range specified *id-time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1` Beat Iterator: *Beat Iterator* generates \"time beat\" given period id appear 'patients.dob' track. period given always hours.  Example:  emr_extract(\"glucose_track\", iterator=10, stime=1000, etime=2000)  create beat iterator period 10 hours starting `stime` `etime` reached. , example, `stime` equals `1000` beat iterator create id iterator points times: 1000, 1010, 1020, ...  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Extended Beat Iterator: *Extended beat iterator* name suggests variation beat iterator. works principle creating time points given period however instead basing times count `stime` accepts additional parameter - track *Id-Time Points table* - instructs initial time point ids. two parameters (period mapping) come list. id required appear certain id appear , skipped iterator.  Anyhow points lie outside `[stime, etime]` range generated.  Example:  # Returns maximal weight patients one year span starting birthdays  emr_vtrack.create(\"weight\", \"weight_track\", func = \"max\", time.shift = c(0, year()))  emr_extract(\"weight\", iterator = list(year(), \"birthday_track\"), stime = 1000, etime = 2000) Periodic Iterator: periodic iterator goes every year/month. can use running  emr_monthly_iterator emr_yearly_iterator.  Example:  iter <- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017))  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)  iter <- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15)  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3) Implicit Iterator: iterator set implicitly value remains `NULL` (default). case track expression analyzed searched track names. track variables virtual track variables point track, track used source track iterator. one track appears track expression, error message printed notifying ambiguity. Revealing Current Iterator Time: evaluation track expression one can access specially defined variable named `EMR_TIME` (Python: `TIME`). variable contains vector (`numpy.ndarray` Python) current iterator times. length vector matches length track variable (vector ).  Note values `EMR_TIME` might set 0. Skip intervals values track variables corresponding indices.  # Returns times current iterator day month  emr_extract(\"emr_time2dayofmonth(EMR_TIME)\", iterator = \"sparse_track\")","code":""},{"path":[]},{"path":"/reference/emr_cor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates correlation statistics for pairs of track expressions — emr_cor","text":"","code":"emr_db.init_examples() emr_cor(\"categorical_track\", c(0, 2, 5),     cor.exprs = c(\"sparse_track\", \"1/dense_track\"),     include.lowest = T, iterator = \"categorical_track\",     keepref = T ) #> $n #> , , sparse_track #>  #>       sparse_track 1/dense_track #> [0,2]            3             3 #> (2,5]            2             2 #>  #> , , 1/dense_track #>  #>       sparse_track 1/dense_track #> [0,2]            3             4 #> (2,5]            2             2 #>  #>  #> $e #> , , sparse_track #>  #>       sparse_track 1/dense_track #> [0,2]           48    0.02608341 #> (2,5]          130    0.02136752 #>  #> , , 1/dense_track #>  #>       sparse_track 1/dense_track #> [0,2]           48    0.03879333 #> (2,5]          130    0.02136752 #>  #>  #> $var #> , , sparse_track #>  #>       sparse_track 1/dense_track #> [0,2]     338.6667  0.0001876685 #> (2,5]   10816.0000  0.0002922054 #>  #> , , 1/dense_track #>  #>       sparse_track 1/dense_track #> [0,2]     338.6667  0.0006253773 #> (2,5]   10816.0000  0.0002922054 #>  #>  #> $cov #> , , sparse_track #>  #>       sparse_track 1/dense_track #> [0,2]     338.6667    -0.2520039 #> (2,5]   10816.0000    -1.7777778 #>  #> , , 1/dense_track #>  #>       sparse_track 1/dense_track #> [0,2]   -0.2520039  0.0006253773 #> (2,5]   -1.7777778  0.0002922054 #>  #>  #> $cor #> , , sparse_track #>  #>       sparse_track 1/dense_track #> [0,2]            1    -0.9995979 #> (2,5]            1    -1.0000000 #>  #> , , 1/dense_track #>  #>       sparse_track 1/dense_track #> [0,2]   -0.9995979             1 #> (2,5]   -1.0000000             1 #>  #>  #> attr(,\"breaks\") #> attr(,\"breaks\")[[1]] #> [1] 0 2 5 #>  emr_cor(\"categorical_track\", c(0, 2, 5),     cor.exprs = c(\"sparse_track\", \"1/dense_track\"),     include.lowest = T, iterator = \"categorical_track\",     keepref = T,     dataframe = TRUE ) #>   categorical_track             i             j n            e          var #> 1             [0,2]  sparse_track  sparse_track 3  48.00000000 3.386667e+02 #> 2             (2,5]  sparse_track  sparse_track 2 130.00000000 1.081600e+04 #> 3             [0,2] 1/dense_track  sparse_track 3   0.02608341 1.876685e-04 #> 4             (2,5] 1/dense_track  sparse_track 2   0.02136752 2.922054e-04 #> 5             [0,2]  sparse_track 1/dense_track 3  48.00000000 3.386667e+02 #> 6             (2,5]  sparse_track 1/dense_track 2 130.00000000 1.081600e+04 #> 7             [0,2] 1/dense_track 1/dense_track 4   0.03879333 6.253773e-04 #> 8             (2,5] 1/dense_track 1/dense_track 2   0.02136752 2.922054e-04 #>                cov        cor #> 1   338.6666666667  1.0000000 #> 2 10816.0000000000  1.0000000 #> 3    -0.2520039101 -0.9995979 #> 4    -1.7777777778 -1.0000000 #> 5    -0.2520039101 -0.9995979 #> 6    -1.7777777778 -1.0000000 #> 7     0.0006253773  1.0000000 #> 8     0.0002922054  1.0000000"},{"path":"/reference/emr_date2time.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts date and hour to internal time format — emr_date2time","title":"Converts date and hour to internal time format — emr_date2time","text":"Converts date hour internal time format.","code":""},{"path":"/reference/emr_date2time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts date and hour to internal time format — emr_date2time","text":"","code":"emr_date2time(day, month, year, hour = 0)"},{"path":"/reference/emr_date2time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts date and hour to internal time format — emr_date2time","text":"day vector days month [1, 31] range month vector months [1, 12] range year vector years hour vector hours [0, 23] range","code":""},{"path":"/reference/emr_date2time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts date and hour to internal time format — emr_date2time","text":"Vector converted times.","code":""},{"path":"/reference/emr_date2time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Converts date and hour to internal time format — emr_date2time","text":"function converts date hour internal time format. Note: earliest valid time 1 March 1867. Note: one arguments ('day', ...) vector, arguments must vectors two identical size scalars. Internally data frame built vectors scalars conversion applied. Hence rules data frame creation apply function.","code":""},{"path":[]},{"path":"/reference/emr_date2time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts date and hour to internal time format — emr_date2time","text":"","code":"emr_db.init_examples()  # 30 January, 1938, 6:00 - birthday of Islam Karimov t <- emr_date2time(30, 1, 1938, 6) emr_time2hour(t) #> [1] 6 emr_time2dayofmonth(t) #> [1] 30 emr_time2month(t) #> [1] 1 emr_time2year(t) #> [1] 1938  # cover all times when Islam Karimov could have been born # (if we don't know the exact hour!) t <- emr_date2time(30, 1, 1938, 0:23)"},{"path":"/reference/emr_db.init.html","id":null,"dir":"Reference","previous_headings":"","what":"Initializes connection with Naryn Database — emr_db.init","title":"Initializes connection with Naryn Database — emr_db.init","text":"Initializes connection Naryn Database.","code":""},{"path":"/reference/emr_db.init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initializes connection with Naryn Database — emr_db.init","text":"","code":"emr_db.init(   global.dir = NULL,   user.dir = NULL,   global.load.on.demand = TRUE,   user.load.on.demand = TRUE,   do.reload = F )"},{"path":"/reference/emr_db.init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initializes connection with Naryn Database — emr_db.init","text":"global.dir root directory global tracks user.dir 'NULL' root directory user tracks global.load..demand see user.load..demand see .reload 'TRUES', rebuilds DB index files","code":""},{"path":"/reference/emr_db.init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initializes connection with Naryn Database — emr_db.init","text":"None.","code":""},{"path":"/reference/emr_db.init.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Initializes connection with Naryn Database — emr_db.init","text":"'emr_db.init' initializes connection Naryn Database facilitating tracks access. 'global.dir' marks root directory global tracks. 'user.dir' parameter specifies directory user tracks. Unlike global tracks user tracks may deleted ('emr_track.rm') new ones can created ('emr_track.create'). 'user.dir' can 'NULL', case operations user tracks disabled. package attached internally calls 'emr_db.init_examples' sets 'global.dir' 'PKGDIR/naryndb/test' 'user.dir' NULL ('PKGDIR' directory package installed). Physical files database supposed managed exclusively Naryn . Manual modification, addition deletion track files may done, yet must ratified via running 'emr_db.reload'. manual changes however (like moving track global space user vice versa) might cause 'emr_db.init' fail. 'emr_db.reload' invoked requires first connection DB established. break deadlock use '.reload=True' parameter within 'emr_db.init'. connect DB rebuild DB index files one step. 'load..demand' 'TRUE' track loaded memory accessed unloaded memory R sessions ends package unloaded. 'load..demand' parameter 'FALSE', tracks specified space (global / user) pre-loaded memory making subsequent track access significantly faster. loaded tracks reside shared memory, R sessions running machine, may also enjoy significant run-time boost. flip side, pre-loading tracks prolongs execution 'emr_db.init' requires enough memory accommodate data. Choosing two modes depends specific needs. 'load..demand=TRUE' seems solid default choice, enviroment frequent short-living R sessions, accessing track one might opt running \"daemon\" - additional permanent R session. daemon pre-load tracks advance stay alive thus boosting run-time later emerging sessions. Upon completion connection established database global variables added environment. variables modified user!","code":""},{"path":[]},{"path":"/reference/emr_db.reload.html","id":null,"dir":"Reference","previous_headings":"","what":"Reloads database — emr_db.reload","title":"Reloads database — emr_db.reload","text":"Reloads database","code":""},{"path":"/reference/emr_db.reload.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reloads database — emr_db.reload","text":"","code":"emr_db.reload()"},{"path":"/reference/emr_db.reload.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reloads database — emr_db.reload","text":"Rebuilds Naryn database index files. Use function manually add/delete/move/modify track files suspect database corrupted: existing tracks found, deleted ones continue appear warning message issued Naryn recommending run 'emr_db.reload'.","code":""},{"path":[]},{"path":"/reference/emr_db.subset.html","id":null,"dir":"Reference","previous_headings":"","what":"Defines an ids subset — emr_db.subset","title":"Defines an ids subset — emr_db.subset","text":"Defines ids subset.","code":""},{"path":"/reference/emr_db.subset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defines an ids subset — emr_db.subset","text":"","code":"emr_db.subset(src = \"\", fraction = NULL, complementary = NULL)"},{"path":"/reference/emr_db.subset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defines an ids subset — emr_db.subset","text":"src track name ids table 'NULL' fraction fraction data sampled 'src' [0,1] range complementary 'TRUE' complementary subset, otherwise 'FALSE'","code":""},{"path":"/reference/emr_db.subset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Defines an ids subset — emr_db.subset","text":"None.","code":""},{"path":"/reference/emr_db.subset.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Defines an ids subset — emr_db.subset","text":"'emr_db.subset' creates ids subset\" (\"viewport\") data \"fraction * sizeof('src')\" size sampling ids 'src'. subset defined ids subset used various functions iterators. ids ignored. 'src' can track name ids table. 'complementary' 'TRUE' complementary set sampled ids used subset. 'src' 'NULL' current subset annihilated.","code":""},{"path":[]},{"path":"/reference/emr_db.subset.ids.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the ids that constitute the current ids subset — emr_db.subset.ids","title":"Returns the ids that constitute the current ids subset — emr_db.subset.ids","text":"Returns ids constitute current ids subset.","code":""},{"path":"/reference/emr_db.subset.ids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the ids that constitute the current ids subset — emr_db.subset.ids","text":"","code":"emr_db.subset.ids()"},{"path":"/reference/emr_db.subset.ids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the ids that constitute the current ids subset — emr_db.subset.ids","text":"Ids table 'NULL'","code":""},{"path":"/reference/emr_db.subset.ids.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns the ids that constitute the current ids subset — emr_db.subset.ids","text":"'emr_db.subset.ids' returns ids constitute current ids subset. ids returned \"ids table\" format. ids subset defined, 'emr_db.subset.ids' returns 'NULL'.","code":""},{"path":[]},{"path":"/reference/emr_db.subset.info.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns information about the current subset — emr_db.subset.info","title":"Returns information about the current subset — emr_db.subset.info","text":"Returns information current subset.","code":""},{"path":"/reference/emr_db.subset.info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns information about the current subset — emr_db.subset.info","text":"","code":"emr_db.subset.info()"},{"path":"/reference/emr_db.subset.info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns information about the current subset — emr_db.subset.info","text":"Information current subset 'NULL'.","code":""},{"path":"/reference/emr_db.subset.info.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns information about the current subset — emr_db.subset.info","text":"'emr_db.subset.info' returns parameters used define current subset 'NULL' subset defined.","code":""},{"path":[]},{"path":"/reference/emr_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates distribution of track expressions — emr_dist","title":"Calculates distribution of track expressions — emr_dist","text":"Calculates distribution track expressions' values given set bins.","code":""},{"path":"/reference/emr_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates distribution of track expressions — emr_dist","text":"","code":"emr_dist(   ...,   include.lowest = FALSE,   right = TRUE,   stime = NULL,   etime = NULL,   iterator = NULL,   keepref = FALSE,   filter = NULL,   dataframe = FALSE,   names = NULL )"},{"path":"/reference/emr_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates distribution of track expressions — emr_dist","text":"include.lowest 'TRUE', lowest (highest, ‘right = FALSE’) value range determined breaks included right 'TRUE' intervals closed right (open left), otherwise vice versa. stime start time scope etime end time scope iterator track expression iterator. 'NULL' iterator determined implicitly based track expressions. See also 'iterator' section. keepref 'TRUE' references preserved iterator. filter Iterator filter. dataframe return data frame instead N-dimensional vector. names names track expressions returned dataframe (relevant dataframe == TRUE) expr track expression breaks breaks determine bin 'NULL'","code":""},{"path":"/reference/emr_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates distribution of track expressions — emr_dist","text":"N-dimensional vector N number 'expr'-'breaks' pairs. dataframe == TRUE - data frame column track expression additional column 'n' counts.","code":""},{"path":"/reference/emr_dist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates distribution of track expressions — emr_dist","text":"function calculates distribution values numeric track expressions given set bins. range bins determined 'breaks' argument. example: 'breaks=c(x1, x2, x3, x4)' represents three different intervals (bins): (x1, x2], (x2, x3], (x3, x4]. track expression constitutes categorical track virtual track source categorical track, 'breaks' allowed 'NULL' meaning breaks derived implicitly unique values underlying track. 'emr_dist' can work number dimensions. one 'expr'-'breaks' pair passed, result multidimensional vector, individual value can accessed [i1,i2,...,] notation, 'i1' first track '' last track expression.","code":""},{"path":"/reference/emr_dist.html","id":"iterator","dir":"Reference","previous_headings":"","what":"iterator","title":"Calculates distribution of track expressions — emr_dist","text":"types iterators: Track iterator: Track iterator returns points (including reference) specified track. Track name specified string. `keepref=FALSE` reference point set `-1`  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func=\"avg\", time.shift=1)  emr_extract(\"glucose\", iterator=\"insulin_shot_track\") Id-Time Points Iterator: Id-Time points iterator generates points *id-time points table*. `keepref=FALSE` reference point set `-1`.  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func = \"avg\", time.shift = 1)  r <- emr_extract(\"insulin_shot_track\") # <-- implicit iterator used  emr_extract(\"glucose\", iterator = r) Ids Iterator: Ids iterator generates points ids taken *ids table* times run `stime` `etime` step 1. `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Example:  stime <- emr_date2time(1, 1, 2016, 0)  etime <- emr_date2time(31, 12, 2016, 23)  emr_extract(\"glucose\", iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime) Time Intervals Iterator: *Time intervals iterator* generates points ids appear 'patients.dob' track times taken *time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`.  Example:  # Returns level hangover patients next day New Year Eve years 2015 2016  stime1 <- emr_date2time(1, 1, 2015, 0)  etime1 <- emr_date2time(1, 1, 2015, 23)  stime2 <- emr_date2time(1, 1, 2016, 0)  etime2 <- emr_date2time(1, 1, 2016, 23)  emr_extract(\"alcohol_level_track\", iterator = data.frame(      stime = c(stime1, stime2),      etime = c(etime1, etime2)  )) Id-Time Intervals Iterator: *Id-Time intervals iterator* generates id points cover `['stime', 'etime']` time range specified *id-time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1` Beat Iterator: *Beat Iterator* generates \"time beat\" given period id appear 'patients.dob' track. period given always hours.  Example:  emr_extract(\"glucose_track\", iterator=10, stime=1000, etime=2000)  create beat iterator period 10 hours starting `stime` `etime` reached. , example, `stime` equals `1000` beat iterator create id iterator points times: 1000, 1010, 1020, ...  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Extended Beat Iterator: *Extended beat iterator* name suggests variation beat iterator. works principle creating time points given period however instead basing times count `stime` accepts additional parameter - track *Id-Time Points table* - instructs initial time point ids. two parameters (period mapping) come list. id required appear certain id appear , skipped iterator.  Anyhow points lie outside `[stime, etime]` range generated.  Example:  # Returns maximal weight patients one year span starting birthdays  emr_vtrack.create(\"weight\", \"weight_track\", func = \"max\", time.shift = c(0, year()))  emr_extract(\"weight\", iterator = list(year(), \"birthday_track\"), stime = 1000, etime = 2000) Periodic Iterator: periodic iterator goes every year/month. can use running  emr_monthly_iterator emr_yearly_iterator.  Example:  iter <- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017))  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)  iter <- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15)  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3) Implicit Iterator: iterator set implicitly value remains `NULL` (default). case track expression analyzed searched track names. track variables virtual track variables point track, track used source track iterator. one track appears track expression, error message printed notifying ambiguity. Revealing Current Iterator Time: evaluation track expression one can access specially defined variable named `EMR_TIME` (Python: `TIME`). variable contains vector (`numpy.ndarray` Python) current iterator times. length vector matches length track variable (vector ).  Note values `EMR_TIME` might set 0. Skip intervals values track variables corresponding indices.  # Returns times current iterator day month  emr_extract(\"emr_time2dayofmonth(EMR_TIME)\", iterator = \"sparse_track\")","code":""},{"path":[]},{"path":"/reference/emr_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates distribution of track expressions — emr_dist","text":"","code":"emr_db.init_examples() emr_dist(\"sparse_track\", c(0, 15, 20, 30, 40, 50), keepref = T) #>  (0,15] (15,20] (20,30] (30,40] (40,50]  #>       4       1       4       1       0  #> attr(,\"breaks\") #> attr(,\"breaks\")[[1]] #> [1]  0 15 20 30 40 50 #>  emr_dist(\"sparse_track\", c(0, 15, 20, 30, 40, 50), keepref = T, dataframe = TRUE) #>   sparse_track n #> 1       (0,15] 4 #> 2      (15,20] 1 #> 3      (20,30] 4 #> 4      (30,40] 1 #> 5      (40,50] 0"},{"path":"/reference/emr_extract.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns evaluated track expression — emr_extract","title":"Returns evaluated track expression — emr_extract","text":"Returns result track expressions evaluation iterator points.","code":""},{"path":"/reference/emr_extract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns evaluated track expression — emr_extract","text":"","code":"emr_extract(   expr,   tidy = F,   sort = F,   names = NULL,   stime = NULL,   etime = NULL,   iterator = NULL,   keepref = F,   filter = NULL )"},{"path":"/reference/emr_extract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns evaluated track expression — emr_extract","text":"expr vector track expressions tidy 'TRUE' result returned \"tidy\"\" format sort 'TRUE' result sorted id, time reference names names track expressions returned value. 'NULL' names set track expression . stime start time scope etime end time scope iterator track expression iterator. 'NULL' iterator determined implicitly based track expressions. See also 'iterator' section. keepref 'TRUE' references preserved iterator. filter Iterator filter.","code":""},{"path":"/reference/emr_extract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns evaluated track expression — emr_extract","text":"set ID-Time points additional columns depending value 'tidy' (see ).","code":""},{"path":"/reference/emr_extract.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns evaluated track expression — emr_extract","text":"function returns result track expressions evaluation iterator stops. 'tidy' 'TRUE' returned value set ID-Time points two additional columns named 'expr' 'value'. 'expr' marks track expression produced value. Rows NaN values omitted tidy format. 'tidy' 'FALSE' returned value set ID-Time points additional column values track expressions. 'sort' 'TRUE' returned value sorted id, time reference, otherwise order guaranteed especially longer runs, multitasking might launched. Sorting requires additional time, switched default. 'names' parameter sets labels track expressions return value. 'names' 'NULL' labels set track expression .","code":""},{"path":"/reference/emr_extract.html","id":"iterator","dir":"Reference","previous_headings":"","what":"iterator","title":"Returns evaluated track expression — emr_extract","text":"types iterators: Track iterator: Track iterator returns points (including reference) specified track. Track name specified string. `keepref=FALSE` reference point set `-1`  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func=\"avg\", time.shift=1)  emr_extract(\"glucose\", iterator=\"insulin_shot_track\") Id-Time Points Iterator: Id-Time points iterator generates points *id-time points table*. `keepref=FALSE` reference point set `-1`.  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func = \"avg\", time.shift = 1)  r <- emr_extract(\"insulin_shot_track\") # <-- implicit iterator used  emr_extract(\"glucose\", iterator = r) Ids Iterator: Ids iterator generates points ids taken *ids table* times run `stime` `etime` step 1. `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Example:  stime <- emr_date2time(1, 1, 2016, 0)  etime <- emr_date2time(31, 12, 2016, 23)  emr_extract(\"glucose\", iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime) Time Intervals Iterator: *Time intervals iterator* generates points ids appear 'patients.dob' track times taken *time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`.  Example:  # Returns level hangover patients next day New Year Eve years 2015 2016  stime1 <- emr_date2time(1, 1, 2015, 0)  etime1 <- emr_date2time(1, 1, 2015, 23)  stime2 <- emr_date2time(1, 1, 2016, 0)  etime2 <- emr_date2time(1, 1, 2016, 23)  emr_extract(\"alcohol_level_track\", iterator = data.frame(      stime = c(stime1, stime2),      etime = c(etime1, etime2)  )) Id-Time Intervals Iterator: *Id-Time intervals iterator* generates id points cover `['stime', 'etime']` time range specified *id-time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1` Beat Iterator: *Beat Iterator* generates \"time beat\" given period id appear 'patients.dob' track. period given always hours.  Example:  emr_extract(\"glucose_track\", iterator=10, stime=1000, etime=2000)  create beat iterator period 10 hours starting `stime` `etime` reached. , example, `stime` equals `1000` beat iterator create id iterator points times: 1000, 1010, 1020, ...  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Extended Beat Iterator: *Extended beat iterator* name suggests variation beat iterator. works principle creating time points given period however instead basing times count `stime` accepts additional parameter - track *Id-Time Points table* - instructs initial time point ids. two parameters (period mapping) come list. id required appear certain id appear , skipped iterator.  Anyhow points lie outside `[stime, etime]` range generated.  Example:  # Returns maximal weight patients one year span starting birthdays  emr_vtrack.create(\"weight\", \"weight_track\", func = \"max\", time.shift = c(0, year()))  emr_extract(\"weight\", iterator = list(year(), \"birthday_track\"), stime = 1000, etime = 2000) Periodic Iterator: periodic iterator goes every year/month. can use running  emr_monthly_iterator emr_yearly_iterator.  Example:  iter <- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017))  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)  iter <- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15)  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3) Implicit Iterator: iterator set implicitly value remains `NULL` (default). case track expression analyzed searched track names. track variables virtual track variables point track, track used source track iterator. one track appears track expression, error message printed notifying ambiguity. Revealing Current Iterator Time: evaluation track expression one can access specially defined variable named `EMR_TIME` (Python: `TIME`). variable contains vector (`numpy.ndarray` Python) current iterator times. length vector matches length track variable (vector ).  Note values `EMR_TIME` might set 0. Skip intervals values track variables corresponding indices.  # Returns times current iterator day month  emr_extract(\"emr_time2dayofmonth(EMR_TIME)\", iterator = \"sparse_track\")","code":""},{"path":[]},{"path":"/reference/emr_extract.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns evaluated track expression — emr_extract","text":"","code":"emr_db.init_examples() emr_extract(\"dense_track\", stime = 1, etime = 3) #>   id time ref dense_track #> 1 22    1  -1          13 #> 2 24    1  -1          13 #> 3 25    1  -1          10 #> 4 25    2  -1          24 #> 5 25    3  -1          34 #> 6 28    1  -1          13"},{"path":"/reference/emr_filter.attr.src.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set attributes of a named filter — emr_filter.attr.src","title":"Get or set attributes of a named filter — emr_filter.attr.src","text":"Get set attributes named filter.","code":""},{"path":"/reference/emr_filter.attr.src.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set attributes of a named filter — emr_filter.attr.src","text":"","code":"emr_filter.attr.src(filter, src)"},{"path":"/reference/emr_filter.attr.src.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set attributes of a named filter — emr_filter.attr.src","text":"filter filter name. src, keepref, time.shift, val, expiration filter attributes.","code":""},{"path":"/reference/emr_filter.attr.src.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set attributes of a named filter — emr_filter.attr.src","text":"None.","code":""},{"path":"/reference/emr_filter.attr.src.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get or set attributes of a named filter — emr_filter.attr.src","text":"'filter' argument used call, functions return corresponding attribute named filter. Otherwise new attribute value set. Note: since inter-dependency exists certain attributes, correctness attributes whole can verified named filter applied track expression. information valid attribute values please refer documentation 'emr_filter.create'.","code":""},{"path":[]},{"path":"/reference/emr_filter.attr.src.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set attributes of a named filter — emr_filter.attr.src","text":"","code":"emr_db.init_examples() emr_filter.create(\"f1\", \"dense_track\", time.shift = c(2, 4)) emr_filter.attr.src(\"f1\") #> [1] \"dense_track\" emr_filter.attr.src(\"f1\", \"sparse_track\") emr_filter.attr.src(\"f1\") #> [1] \"sparse_track\""},{"path":"/reference/emr_filter.create.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a new named filter — emr_filter.create","title":"Creates a new named filter — emr_filter.create","text":"Creates new named filter.","code":""},{"path":"/reference/emr_filter.create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a new named filter — emr_filter.create","text":"","code":"emr_filter.create(   filter,   src,   keepref = F,   time.shift = NULL,   val = NULL,   expiration = NULL )"},{"path":"/reference/emr_filter.create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a new named filter — emr_filter.create","text":"filter filter name src source (track name id-time table) keepref 'TRUE' 'FALSE' time.shift time shift expansion iterator time val selected values expiration expiration period","code":""},{"path":"/reference/emr_filter.create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a new named filter — emr_filter.create","text":"Name filter (invisibly)","code":""},{"path":"/reference/emr_filter.create.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates a new named filter — emr_filter.create","text":"function creates new named filter. 'src' can either track name id-time table - data frame first columns named \"id\", \"time\" optional \"ref\". 'val' 'NULL', time window filter required contain least one value vector 'val'. 'val' allowed used 'src' name categorical track. 'expiration' 'NULL' filter window contains value time 't', existence previous values time window [t-expiration, t-1] (aka: \"expiration window\") checked. values found expiration window, filter returns 'TRUE', otherwise 'FALSE'. 'expiration' allowed used 'src' name categorical track 'keepref' 'FALSE'. 'val' 'expiration' 'NULL' values 'val' vector checked time window expiration window. Note: 'time.shift' can used 'keepref' 'FALSE'.","code":""},{"path":[]},{"path":"/reference/emr_filter.create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a new named filter — emr_filter.create","text":"","code":"emr_db.init_examples() emr_filter.create(\"f1\", \"dense_track\", time.shift = c(2, 4)) emr_filter.create(\"f2\", \"dense_track\", keepref = T) emr_extract(\"sparse_track\", filter = \"!f1 & f2\") #>   id time ref sparse_track #> 1 25   12  -1          124 #> 2 27   23  -1          234"},{"path":"/reference/emr_filter.exists.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks whether the named filter exists — emr_filter.exists","title":"Checks whether the named filter exists — emr_filter.exists","text":"Checks whether named filter exists.","code":""},{"path":"/reference/emr_filter.exists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks whether the named filter exists — emr_filter.exists","text":"","code":"emr_filter.exists(filter)"},{"path":"/reference/emr_filter.exists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checks whether the named filter exists — emr_filter.exists","text":"filter filter name","code":""},{"path":"/reference/emr_filter.exists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks whether the named filter exists — emr_filter.exists","text":"'TRUE', named filter exists, otherwise 'FALSE'.","code":""},{"path":"/reference/emr_filter.exists.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Checks whether the named filter exists — emr_filter.exists","text":"function checks whether named filter exists.","code":""},{"path":[]},{"path":"/reference/emr_filter.exists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Checks whether the named filter exists — emr_filter.exists","text":"","code":"emr_db.init_examples() emr_filter.create(\"f1\", \"dense_track\", time.shift = c(2, 4)) emr_filter.exists(\"f1\") #> [1] TRUE"},{"path":"/reference/emr_filter.info.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the definition of a named filter — emr_filter.info","title":"Returns the definition of a named filter — emr_filter.info","text":"Returns definition named filter.","code":""},{"path":"/reference/emr_filter.info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the definition of a named filter — emr_filter.info","text":"","code":"emr_filter.info(filter)"},{"path":"/reference/emr_filter.info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the definition of a named filter — emr_filter.info","text":"filter filter name","code":""},{"path":"/reference/emr_filter.info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the definition of a named filter — emr_filter.info","text":"Internal representation named filter.","code":""},{"path":"/reference/emr_filter.info.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns the definition of a named filter — emr_filter.info","text":"function returns internal represenation named filter.","code":""},{"path":[]},{"path":"/reference/emr_filter.info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the definition of a named filter — emr_filter.info","text":"","code":"emr_db.init_examples() emr_filter.create(\"f1\", \"dense_track\", time.shift = c(2, 4)) emr_filter.info(\"f1\") #> $src #> [1] \"dense_track\" #>  #> $time_shift #> [1] 2 4 #>  #> $keepref #> [1] FALSE #>  #> $val #> NULL #>  #> $expiration #> NULL #>"},{"path":"/reference/emr_filter.ls.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns a list of named filters — emr_filter.ls","title":"Returns a list of named filters — emr_filter.ls","text":"Returns list named filters.","code":""},{"path":"/reference/emr_filter.ls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns a list of named filters — emr_filter.ls","text":"","code":"emr_filter.ls(   pattern = \"\",   ignore.case = FALSE,   perl = FALSE,   fixed = FALSE,   useBytes = FALSE )"},{"path":"/reference/emr_filter.ls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns a list of named filters — emr_filter.ls","text":"pattern, ignore.case, perl, fixed, useBytes see 'grep'","code":""},{"path":"/reference/emr_filter.ls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns a list of named filters — emr_filter.ls","text":"array contains names filters.","code":""},{"path":"/reference/emr_filter.ls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns a list of named filters — emr_filter.ls","text":"function returns list named filters exist current R environment match pattern (see 'grep'). called without arguments named filters returned.","code":""},{"path":[]},{"path":"/reference/emr_filter.ls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns a list of named filters — emr_filter.ls","text":"","code":"emr_db.init_examples() emr_filter.create(\"f1\", \"dense_track\", time.shift = c(2, 4)) emr_filter.create(\"f2\", \"dense_track\", keepref = T) emr_filter.ls() #> [1] \"f1\" \"f2\" emr_filter.ls(\"*2\") #> [1] \"f2\""},{"path":"/reference/emr_filter.rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Deletes a named filter — emr_filter.rm","title":"Deletes a named filter — emr_filter.rm","text":"Deletes named filter.","code":""},{"path":"/reference/emr_filter.rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deletes a named filter — emr_filter.rm","text":"","code":"emr_filter.rm(filter)"},{"path":"/reference/emr_filter.rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deletes a named filter — emr_filter.rm","text":"filter filter name","code":""},{"path":"/reference/emr_filter.rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deletes a named filter — emr_filter.rm","text":"None.","code":""},{"path":"/reference/emr_filter.rm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deletes a named filter — emr_filter.rm","text":"function deletes named filter current R environment.","code":""},{"path":[]},{"path":"/reference/emr_filter.rm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deletes a named filter — emr_filter.rm","text":"","code":"emr_db.init_examples() emr_filter.create(\"f1\", \"dense_track\", time.shift = c(2, 4)) emr_filter.create(\"f2\", \"dense_track\", keepref = T) emr_filter.ls() #> [1] \"f1\" \"f2\" emr_filter.rm(\"f1\") emr_filter.ls() #> [1] \"f2\""},{"path":"/reference/emr_ids_coverage.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns ids coverage per track — emr_ids_coverage","title":"Returns ids coverage per track — emr_ids_coverage","text":"Returns ids coverage per track.","code":""},{"path":"/reference/emr_ids_coverage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns ids coverage per track — emr_ids_coverage","text":"","code":"emr_ids_coverage(ids, tracks, stime = NULL, etime = NULL, filter = NULL)"},{"path":"/reference/emr_ids_coverage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns ids coverage per track — emr_ids_coverage","text":"ids track name Ids Table tracks vector track names stime start time scope etime end time scope filter iterator filter","code":""},{"path":"/reference/emr_ids_coverage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns ids coverage per track — emr_ids_coverage","text":"vector containing ids count track.","code":""},{"path":"/reference/emr_ids_coverage.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns ids coverage per track — emr_ids_coverage","text":"function accepts set ids vector categorical tracks. track calculates many ids appear track. id counted . Ids can originate track provided within Ids Table. Note: internal iterator runs track defined 'keepref=T'.","code":""},{"path":[]},{"path":"/reference/emr_ids_coverage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns ids coverage per track — emr_ids_coverage","text":"","code":"emr_db.init_examples() emr_ids_coverage(data.frame(id = c(15, 24, 27)), \"categorical_track\") #> categorical_track  #>                 2"},{"path":"/reference/emr_ids_vals_coverage.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns ids coverage per value track — emr_ids_vals_coverage","title":"Returns ids coverage per value track — emr_ids_vals_coverage","text":"Returns ids coverage per value track.","code":""},{"path":"/reference/emr_ids_vals_coverage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns ids coverage per value track — emr_ids_vals_coverage","text":"","code":"emr_ids_vals_coverage(ids, tracks, stime = NULL, etime = NULL, filter = NULL)"},{"path":"/reference/emr_ids_vals_coverage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns ids coverage per value track — emr_ids_vals_coverage","text":"ids track name Ids Table tracks vector track names stime start time scope etime end time scope filter iterator filter","code":""},{"path":"/reference/emr_ids_vals_coverage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns ids coverage per value track — emr_ids_vals_coverage","text":"data frame containing number ids track value.","code":""},{"path":"/reference/emr_ids_vals_coverage.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns ids coverage per value track — emr_ids_vals_coverage","text":"function accepts set ids vector categorical tracks. track value calculates many ids share value. id counted . data frame 3 columns 'track', 'val' 'count' returned. Ids can originate track provided within Ids Table. Note: internal iterator runs track defined 'keepref=T'.","code":""},{"path":[]},{"path":"/reference/emr_ids_vals_coverage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns ids coverage per value track — emr_ids_vals_coverage","text":"","code":"emr_db.init_examples() emr_ids_vals_coverage(data.frame(id = c(15, 24, 27)), \"categorical_track\") #>               track val count #> 1 categorical_track   0     0 #> 2 categorical_track   1     0 #> 3 categorical_track   2     2 #> 4 categorical_track   3     2 #> 5 categorical_track   4     1"},{"path":"/reference/emr_monthly_iterator.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an iterator that goes every year/month — emr_monthly_iterator","title":"Create an iterator that goes every year/month — emr_monthly_iterator","text":"Create iterator goes every year/month, stime. etime set, iterator go every year/month last point <= etime. month years set, iterator set every year/month ntimes. parameters set, iterator go etime early n times etime.","code":""},{"path":"/reference/emr_monthly_iterator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an iterator that goes every year/month — emr_monthly_iterator","text":"","code":"emr_monthly_iterator(stime, etime = NULL, n = NULL)  emr_yearly_iterator(stime, etime = NULL, n = NULL)"},{"path":"/reference/emr_monthly_iterator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an iterator that goes every year/month — emr_monthly_iterator","text":"stime date first point machine format (use emr_date2time) etime end time scope (can NULL months parameter set) n number months / years","code":""},{"path":"/reference/emr_monthly_iterator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an iterator that goes every year/month — emr_monthly_iterator","text":"id time data frame can used iterator","code":""},{"path":"/reference/emr_monthly_iterator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an iterator that goes every year/month — emr_monthly_iterator","text":"","code":"if (FALSE) { iter <- emr_monthly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017)) emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)  iter <- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15) emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)  iter <- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017)) emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)  iter <- emr_yearly_iterator(emr_date2time(1, 1, 2002), n = 4) emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3) }"},{"path":"/reference/emr_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates quantiles of a track expression — emr_quantiles","title":"Calculates quantiles of a track expression — emr_quantiles","text":"Calculates quantiles track expression given percentiles.","code":""},{"path":"/reference/emr_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates quantiles of a track expression — emr_quantiles","text":"","code":"emr_quantiles(   expr,   percentiles = 0.5,   stime = NULL,   etime = NULL,   iterator = NULL,   keepref = F,   filter = NULL )"},{"path":"/reference/emr_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates quantiles of a track expression — emr_quantiles","text":"expr track expression percentiles array percentiles quantiles [0, 1] range stime start time scope etime end time scope iterator track expression iterator. 'NULL' iterator determined implicitly based track expression. See also 'iterator' section. keepref 'TRUE' references preserved iterator. filter Iterator filter.","code":""},{"path":"/reference/emr_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates quantiles of a track expression — emr_quantiles","text":"array represent quantiles.","code":""},{"path":"/reference/emr_quantiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates quantiles of a track expression — emr_quantiles","text":"function calculates quantiles given percentiles. data size exceeds limit (see: 'getOption(emr_max.data.size)'), data randomly sampled fit limit. warning message generated .","code":""},{"path":"/reference/emr_quantiles.html","id":"iterator","dir":"Reference","previous_headings":"","what":"iterator","title":"Calculates quantiles of a track expression — emr_quantiles","text":"types iterators: Track iterator: Track iterator returns points (including reference) specified track. Track name specified string. `keepref=FALSE` reference point set `-1`  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func=\"avg\", time.shift=1)  emr_extract(\"glucose\", iterator=\"insulin_shot_track\") Id-Time Points Iterator: Id-Time points iterator generates points *id-time points table*. `keepref=FALSE` reference point set `-1`.  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func = \"avg\", time.shift = 1)  r <- emr_extract(\"insulin_shot_track\") # <-- implicit iterator used  emr_extract(\"glucose\", iterator = r) Ids Iterator: Ids iterator generates points ids taken *ids table* times run `stime` `etime` step 1. `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Example:  stime <- emr_date2time(1, 1, 2016, 0)  etime <- emr_date2time(31, 12, 2016, 23)  emr_extract(\"glucose\", iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime) Time Intervals Iterator: *Time intervals iterator* generates points ids appear 'patients.dob' track times taken *time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`.  Example:  # Returns level hangover patients next day New Year Eve years 2015 2016  stime1 <- emr_date2time(1, 1, 2015, 0)  etime1 <- emr_date2time(1, 1, 2015, 23)  stime2 <- emr_date2time(1, 1, 2016, 0)  etime2 <- emr_date2time(1, 1, 2016, 23)  emr_extract(\"alcohol_level_track\", iterator = data.frame(      stime = c(stime1, stime2),      etime = c(etime1, etime2)  )) Id-Time Intervals Iterator: *Id-Time intervals iterator* generates id points cover `['stime', 'etime']` time range specified *id-time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1` Beat Iterator: *Beat Iterator* generates \"time beat\" given period id appear 'patients.dob' track. period given always hours.  Example:  emr_extract(\"glucose_track\", iterator=10, stime=1000, etime=2000)  create beat iterator period 10 hours starting `stime` `etime` reached. , example, `stime` equals `1000` beat iterator create id iterator points times: 1000, 1010, 1020, ...  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Extended Beat Iterator: *Extended beat iterator* name suggests variation beat iterator. works principle creating time points given period however instead basing times count `stime` accepts additional parameter - track *Id-Time Points table* - instructs initial time point ids. two parameters (period mapping) come list. id required appear certain id appear , skipped iterator.  Anyhow points lie outside `[stime, etime]` range generated.  Example:  # Returns maximal weight patients one year span starting birthdays  emr_vtrack.create(\"weight\", \"weight_track\", func = \"max\", time.shift = c(0, year()))  emr_extract(\"weight\", iterator = list(year(), \"birthday_track\"), stime = 1000, etime = 2000) Periodic Iterator: periodic iterator goes every year/month. can use running  emr_monthly_iterator emr_yearly_iterator.  Example:  iter <- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017))  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)  iter <- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15)  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3) Implicit Iterator: iterator set implicitly value remains `NULL` (default). case track expression analyzed searched track names. track variables virtual track variables point track, track used source track iterator. one track appears track expression, error message printed notifying ambiguity. Revealing Current Iterator Time: evaluation track expression one can access specially defined variable named `EMR_TIME` (Python: `TIME`). variable contains vector (`numpy.ndarray` Python) current iterator times. length vector matches length track variable (vector ).  Note values `EMR_TIME` might set 0. Skip intervals values track variables corresponding indices.  # Returns times current iterator day month  emr_extract(\"emr_time2dayofmonth(EMR_TIME)\", iterator = \"sparse_track\")","code":""},{"path":[]},{"path":"/reference/emr_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates quantiles of a track expression — emr_quantiles","text":"","code":"emr_db.init_examples() emr_quantiles(\"sparse_track\", c(0.1, 0.6, 0.8)) #>   0.1   0.6   0.8  #>  13.0  90.8 168.0"},{"path":"/reference/emr_screen.html","id":null,"dir":"Reference","previous_headings":"","what":"Finds Id-Time points that match track expression — emr_screen","title":"Finds Id-Time points that match track expression — emr_screen","text":"Finds patient-time pairs track expression 'TRUE'.","code":""},{"path":"/reference/emr_screen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finds Id-Time points that match track expression — emr_screen","text":"","code":"emr_screen(   expr,   sort = F,   stime = NULL,   etime = NULL,   iterator = NULL,   keepref = F,   filter = NULL )"},{"path":"/reference/emr_screen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finds Id-Time points that match track expression — emr_screen","text":"expr logical track expression sort 'TRUE' result sorted id, time reference stime start time scope etime end time scope iterator track expression iterator. 'NULL' iterator determined implicitly based track expression. See also 'iterator' section. keepref 'TRUE' references preserved iterator. filter Iterator filter.","code":""},{"path":"/reference/emr_screen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finds Id-Time points that match track expression — emr_screen","text":"set Id-Time points match track expression.","code":""},{"path":"/reference/emr_screen.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Finds Id-Time points that match track expression — emr_screen","text":"function finds Id-Time points track expression's value 'TRUE'. 'sort' 'TRUE' returned value sorted id, time reference, otherwise order guaranteed especially longer runs, multitasking might launched. Sorting requires additional time, switched default.","code":""},{"path":"/reference/emr_screen.html","id":"iterator","dir":"Reference","previous_headings":"","what":"iterator","title":"Finds Id-Time points that match track expression — emr_screen","text":"types iterators: Track iterator: Track iterator returns points (including reference) specified track. Track name specified string. `keepref=FALSE` reference point set `-1`  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func=\"avg\", time.shift=1)  emr_extract(\"glucose\", iterator=\"insulin_shot_track\") Id-Time Points Iterator: Id-Time points iterator generates points *id-time points table*. `keepref=FALSE` reference point set `-1`.  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func = \"avg\", time.shift = 1)  r <- emr_extract(\"insulin_shot_track\") # <-- implicit iterator used  emr_extract(\"glucose\", iterator = r) Ids Iterator: Ids iterator generates points ids taken *ids table* times run `stime` `etime` step 1. `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Example:  stime <- emr_date2time(1, 1, 2016, 0)  etime <- emr_date2time(31, 12, 2016, 23)  emr_extract(\"glucose\", iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime) Time Intervals Iterator: *Time intervals iterator* generates points ids appear 'patients.dob' track times taken *time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`.  Example:  # Returns level hangover patients next day New Year Eve years 2015 2016  stime1 <- emr_date2time(1, 1, 2015, 0)  etime1 <- emr_date2time(1, 1, 2015, 23)  stime2 <- emr_date2time(1, 1, 2016, 0)  etime2 <- emr_date2time(1, 1, 2016, 23)  emr_extract(\"alcohol_level_track\", iterator = data.frame(      stime = c(stime1, stime2),      etime = c(etime1, etime2)  )) Id-Time Intervals Iterator: *Id-Time intervals iterator* generates id points cover `['stime', 'etime']` time range specified *id-time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1` Beat Iterator: *Beat Iterator* generates \"time beat\" given period id appear 'patients.dob' track. period given always hours.  Example:  emr_extract(\"glucose_track\", iterator=10, stime=1000, etime=2000)  create beat iterator period 10 hours starting `stime` `etime` reached. , example, `stime` equals `1000` beat iterator create id iterator points times: 1000, 1010, 1020, ...  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Extended Beat Iterator: *Extended beat iterator* name suggests variation beat iterator. works principle creating time points given period however instead basing times count `stime` accepts additional parameter - track *Id-Time Points table* - instructs initial time point ids. two parameters (period mapping) come list. id required appear certain id appear , skipped iterator.  Anyhow points lie outside `[stime, etime]` range generated.  Example:  # Returns maximal weight patients one year span starting birthdays  emr_vtrack.create(\"weight\", \"weight_track\", func = \"max\", time.shift = c(0, year()))  emr_extract(\"weight\", iterator = list(year(), \"birthday_track\"), stime = 1000, etime = 2000) Periodic Iterator: periodic iterator goes every year/month. can use running  emr_monthly_iterator emr_yearly_iterator.  Example:  iter <- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017))  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)  iter <- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15)  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3) Implicit Iterator: iterator set implicitly value remains `NULL` (default). case track expression analyzed searched track names. track variables virtual track variables point track, track used source track iterator. one track appears track expression, error message printed notifying ambiguity. Revealing Current Iterator Time: evaluation track expression one can access specially defined variable named `EMR_TIME` (Python: `TIME`). variable contains vector (`numpy.ndarray` Python) current iterator times. length vector matches length track variable (vector ).  Note values `EMR_TIME` might set 0. Skip intervals values track variables corresponding indices.  # Returns times current iterator day month  emr_extract(\"emr_time2dayofmonth(EMR_TIME)\", iterator = \"sparse_track\")","code":""},{"path":[]},{"path":"/reference/emr_screen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finds Id-Time points that match track expression — emr_screen","text":"","code":"emr_db.init_examples() emr_screen(\"sparse_track == 13 | dense_track < 80\",     iterator = \"sparse_track\", keepref = T ) #>    id time ref #> 1   5    1   3 #> 2  10    1   3 #> 3  25    1   0 #> 4  25    2   0 #> 5  25    2   2 #> 6  25    2   6 #> 7  25    2   8 #> 8  25    3   4 #> 9  25    6   0 #> 10 25    6   2 #> 11 40    1   3"},{"path":"/reference/emr_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates summary statistics of track expression — emr_summary","title":"Calculates summary statistics of track expression — emr_summary","text":"Calculates summary statistics track expression.","code":""},{"path":"/reference/emr_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates summary statistics of track expression — emr_summary","text":"","code":"emr_summary(   expr,   stime = NULL,   etime = NULL,   iterator = NULL,   keepref = F,   filter = NULL )"},{"path":"/reference/emr_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates summary statistics of track expression — emr_summary","text":"expr track expression. stime start time scope. etime end time scope. iterator track expression iterator. 'NULL' iterator determined implicitly based track expressions. See also 'iterator' section. keepref 'TRUE' references preserved iterator. filter Iterator filter.","code":""},{"path":"/reference/emr_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates summary statistics of track expression — emr_summary","text":"array represents summary statistics.","code":""},{"path":"/reference/emr_summary.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculates summary statistics of track expression — emr_summary","text":"function returns summary statistics track expression: total number values, number NaN values, min, max, sum, mean standard deviation values.","code":""},{"path":"/reference/emr_summary.html","id":"iterator","dir":"Reference","previous_headings":"","what":"iterator","title":"Calculates summary statistics of track expression — emr_summary","text":"types iterators: Track iterator: Track iterator returns points (including reference) specified track. Track name specified string. `keepref=FALSE` reference point set `-1`  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func=\"avg\", time.shift=1)  emr_extract(\"glucose\", iterator=\"insulin_shot_track\") Id-Time Points Iterator: Id-Time points iterator generates points *id-time points table*. `keepref=FALSE` reference point set `-1`.  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func = \"avg\", time.shift = 1)  r <- emr_extract(\"insulin_shot_track\") # <-- implicit iterator used  emr_extract(\"glucose\", iterator = r) Ids Iterator: Ids iterator generates points ids taken *ids table* times run `stime` `etime` step 1. `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Example:  stime <- emr_date2time(1, 1, 2016, 0)  etime <- emr_date2time(31, 12, 2016, 23)  emr_extract(\"glucose\", iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime) Time Intervals Iterator: *Time intervals iterator* generates points ids appear 'patients.dob' track times taken *time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`.  Example:  # Returns level hangover patients next day New Year Eve years 2015 2016  stime1 <- emr_date2time(1, 1, 2015, 0)  etime1 <- emr_date2time(1, 1, 2015, 23)  stime2 <- emr_date2time(1, 1, 2016, 0)  etime2 <- emr_date2time(1, 1, 2016, 23)  emr_extract(\"alcohol_level_track\", iterator = data.frame(      stime = c(stime1, stime2),      etime = c(etime1, etime2)  )) Id-Time Intervals Iterator: *Id-Time intervals iterator* generates id points cover `['stime', 'etime']` time range specified *id-time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1` Beat Iterator: *Beat Iterator* generates \"time beat\" given period id appear 'patients.dob' track. period given always hours.  Example:  emr_extract(\"glucose_track\", iterator=10, stime=1000, etime=2000)  create beat iterator period 10 hours starting `stime` `etime` reached. , example, `stime` equals `1000` beat iterator create id iterator points times: 1000, 1010, 1020, ...  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Extended Beat Iterator: *Extended beat iterator* name suggests variation beat iterator. works principle creating time points given period however instead basing times count `stime` accepts additional parameter - track *Id-Time Points table* - instructs initial time point ids. two parameters (period mapping) come list. id required appear certain id appear , skipped iterator.  Anyhow points lie outside `[stime, etime]` range generated.  Example:  # Returns maximal weight patients one year span starting birthdays  emr_vtrack.create(\"weight\", \"weight_track\", func = \"max\", time.shift = c(0, year()))  emr_extract(\"weight\", iterator = list(year(), \"birthday_track\"), stime = 1000, etime = 2000) Periodic Iterator: periodic iterator goes every year/month. can use running  emr_monthly_iterator emr_yearly_iterator.  Example:  iter <- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017))  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)  iter <- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15)  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3) Implicit Iterator: iterator set implicitly value remains `NULL` (default). case track expression analyzed searched track names. track variables virtual track variables point track, track used source track iterator. one track appears track expression, error message printed notifying ambiguity. Revealing Current Iterator Time: evaluation track expression one can access specially defined variable named `EMR_TIME` (Python: `TIME`). variable contains vector (`numpy.ndarray` Python) current iterator times. length vector matches length track variable (vector ).  Note values `EMR_TIME` might set 0. Skip intervals values track variables corresponding indices.  # Returns times current iterator day month  emr_extract(\"emr_time2dayofmonth(EMR_TIME)\", iterator = \"sparse_track\")","code":""},{"path":[]},{"path":"/reference/emr_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates summary statistics of track expression — emr_summary","text":"","code":"emr_db.init_examples() emr_summary(\"sparse_track\") #> Total values   NaN values          Min          Max          Sum         Mean  #>      14.0000       0.0000      10.0000     500.0000    1539.0000     109.9286  #>      Std dev  #>     135.2937"},{"path":"/reference/emr_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert time periods to internal time format — emr_time","title":"Convert time periods to internal time format — emr_time","text":"Convert time periods internal time format","code":""},{"path":"/reference/emr_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert time periods to internal time format — emr_time","text":"","code":"emr_time(days = 0, months = 0, years = 0, hours = 0)  hours(n)  hour()  days(n)  day()  weeks(n)  week()  day()  months(n)  month()  years(n)  year()"},{"path":"/reference/emr_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert time periods to internal time format — emr_time","text":"days number days months number months years number years hours number hours","code":""},{"path":"/reference/emr_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert time periods to internal time format — emr_time","text":"Machine time format (number hours)","code":""},{"path":"/reference/emr_time.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert time periods to internal time format — emr_time","text":"emr_time converts generic number years, months day hours internal naryn machine format (hours). year, years, month, months, week, weeks, day, days, hour, hours convenience functions get time period explicitly.","code":""},{"path":"/reference/emr_time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert time periods to internal time format — emr_time","text":"","code":"emr_time(5) # 5 days #> [1] 120 emr_time(months = 4) # 4 months #> [1] 2880 emr_time(2, 4, 1) # 1 year, 4 months and 2 days #> [1] 11688  year() # 1 year #> [1] 8760 years(5) # 5 years #> [1] 43800 month() # 1 month #> [1] 720 months(5) # 5 months #> [1] 3600 day() # 1 day #> [1] 24 days(9) # 9 days #> [1] 216 week() # 1 week #> [1] 168 weeks(2) # 2 weeks #> [1] 336 hour() # 1 hour #> [1] 1 hours(5) # 5 hours #> [1] 5"},{"path":"/reference/emr_time2date.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert from internal time to year, month, day, hour — emr_time2date","title":"Convert from internal time to year, month, day, hour — emr_time2date","text":"Convert internal time year, month, day, hour","code":""},{"path":"/reference/emr_time2date.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert from internal time to year, month, day, hour — emr_time2date","text":"","code":"emr_time2date(time)"},{"path":"/reference/emr_time2date.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert from internal time to year, month, day, hour — emr_time2date","text":"time vector times internal format","code":""},{"path":"/reference/emr_time2date.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert from internal time to year, month, day, hour — emr_time2date","text":"data frame columns named 'year', 'month', 'day' 'hour'","code":""},{"path":"/reference/emr_time2date.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert from internal time to year, month, day, hour — emr_time2date","text":"","code":"emr_db.init_examples()  # 30 January, 1938, 6:00 - birthday of Islam Karimov t1 <- emr_date2time(30, 1, 1938, 6) # September 2, 2016, 7:00 - death of Islam Karimov t2 <- emr_date2time(2, 9, 2016, 7) emr_time2date(c(t1, t2)) #>   day month year hour #> 1  30     1 1938    6 #> 2   2     9 2016    7"},{"path":"/reference/emr_time2dayofmonth.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts time from internal format to a day of month — emr_time2dayofmonth","title":"Converts time from internal format to a day of month — emr_time2dayofmonth","text":"Converts time internal format day month.","code":""},{"path":"/reference/emr_time2dayofmonth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts time from internal format to a day of month — emr_time2dayofmonth","text":"","code":"emr_time2dayofmonth(time)"},{"path":"/reference/emr_time2dayofmonth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts time from internal format to a day of month — emr_time2dayofmonth","text":"time vector times internal format","code":""},{"path":"/reference/emr_time2dayofmonth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts time from internal format to a day of month — emr_time2dayofmonth","text":"Vector converted times.","code":""},{"path":"/reference/emr_time2dayofmonth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Converts time from internal format to a day of month — emr_time2dayofmonth","text":"function converts time internal format day month [1, 31] range.","code":""},{"path":[]},{"path":"/reference/emr_time2dayofmonth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts time from internal format to a day of month — emr_time2dayofmonth","text":"","code":"emr_db.init_examples()  # 30 January, 1938, 6:00 - birthday of Islam Karimov t <- emr_date2time(30, 1, 1938, 6) emr_time2hour(t) #> [1] 6 emr_time2dayofmonth(t) #> [1] 30 emr_time2month(t) #> [1] 1 emr_time2year(t) #> [1] 1938"},{"path":"/reference/emr_time2hour.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts time from internal format to an hour — emr_time2hour","title":"Converts time from internal format to an hour — emr_time2hour","text":"Converts time internal format hour.","code":""},{"path":"/reference/emr_time2hour.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts time from internal format to an hour — emr_time2hour","text":"","code":"emr_time2hour(time)"},{"path":"/reference/emr_time2hour.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts time from internal format to an hour — emr_time2hour","text":"time vector times internal format","code":""},{"path":"/reference/emr_time2hour.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts time from internal format to an hour — emr_time2hour","text":"Vector converted times.","code":""},{"path":"/reference/emr_time2hour.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Converts time from internal format to an hour — emr_time2hour","text":"function converts time internal format hour [0, 23] range.","code":""},{"path":[]},{"path":"/reference/emr_time2hour.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts time from internal format to an hour — emr_time2hour","text":"","code":"emr_db.init_examples()  # 30 January, 1938, 6:00 - birthday of Islam Karimov t <- emr_date2time(30, 1, 1938, 6) emr_time2hour(t) #> [1] 6 emr_time2dayofmonth(t) #> [1] 30 emr_time2month(t) #> [1] 1 emr_time2year(t) #> [1] 1938"},{"path":"/reference/emr_time2month.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts time from internal format to a month — emr_time2month","title":"Converts time from internal format to a month — emr_time2month","text":"Converts time internal format month.","code":""},{"path":"/reference/emr_time2month.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts time from internal format to a month — emr_time2month","text":"","code":"emr_time2month(time)"},{"path":"/reference/emr_time2month.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts time from internal format to a month — emr_time2month","text":"time vector times internal format","code":""},{"path":"/reference/emr_time2month.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts time from internal format to a month — emr_time2month","text":"Vector converted times.","code":""},{"path":"/reference/emr_time2month.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Converts time from internal format to a month — emr_time2month","text":"function converts time internal format month [1, 12] range.","code":""},{"path":[]},{"path":"/reference/emr_time2month.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts time from internal format to a month — emr_time2month","text":"","code":"emr_db.init_examples()  # 30 January, 1938, 6:00 - birthday of Islam Karimov t <- emr_date2time(30, 1, 1938, 6) emr_time2hour(t) #> [1] 6 emr_time2dayofmonth(t) #> [1] 30 emr_time2month(t) #> [1] 1 emr_time2year(t) #> [1] 1938"},{"path":"/reference/emr_time2year.html","id":null,"dir":"Reference","previous_headings":"","what":"Converts time from internal format to a year — emr_time2year","title":"Converts time from internal format to a year — emr_time2year","text":"Converts time internal format year.","code":""},{"path":"/reference/emr_time2year.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Converts time from internal format to a year — emr_time2year","text":"","code":"emr_time2year(time)"},{"path":"/reference/emr_time2year.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Converts time from internal format to a year — emr_time2year","text":"time vector times internal format","code":""},{"path":"/reference/emr_time2year.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Converts time from internal format to a year — emr_time2year","text":"Vector converted times.","code":""},{"path":"/reference/emr_time2year.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Converts time from internal format to a year — emr_time2year","text":"function converts time internal format year.","code":""},{"path":[]},{"path":"/reference/emr_time2year.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Converts time from internal format to a year — emr_time2year","text":"","code":"emr_db.init_examples()  # 30 January, 1938, 6:00 - birthday of Islam Karimov t <- emr_date2time(30, 1, 1938, 6) emr_time2hour(t) #> [1] 6 emr_time2dayofmonth(t) #> [1] 30 emr_time2month(t) #> [1] 1 emr_time2year(t) #> [1] 1938"},{"path":"/reference/emr_traceback.html","id":null,"dir":"Reference","previous_headings":"","what":"Prints call stack of the last uncaught error — emr_traceback","title":"Prints call stack of the last uncaught error — emr_traceback","text":"Prints call stack last uncaught error friendly way.","code":""},{"path":"/reference/emr_traceback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prints call stack of the last uncaught error — emr_traceback","text":"","code":"emr_traceback(x = NULL, max.lines = getOption(\"deparse.max.lines\"))"},{"path":"/reference/emr_traceback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prints call stack of the last uncaught error — emr_traceback","text":"x see 'traceback' max.lines see 'traceback'","code":""},{"path":"/reference/emr_traceback.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prints call stack of the last uncaught error — emr_traceback","text":"See 'traceback'.","code":""},{"path":"/reference/emr_traceback.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prints call stack of the last uncaught error — emr_traceback","text":"Similarly 'traceback' function prints call stack last uncaught error. Yet 'emr_traceback' friendly way omitting calls occurred inside library.","code":""},{"path":[]},{"path":"/reference/emr_traceback.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prints call stack of the last uncaught error — emr_traceback","text":"","code":"emr_db.init_examples() f <- function() {     emr_screen(\"blablabla\") } f() #> Error: Unable to implicitly set iterator policy: track expression (blablabla) does not contain any tracks emr_traceback() #> No traceback available"},{"path":"/reference/emr_track.addto.html","id":null,"dir":"Reference","previous_headings":"","what":"Adds new records to a track — emr_track.addto","title":"Adds new records to a track — emr_track.addto","text":"Adds new records track TAB-delimited file data frame.","code":""},{"path":"/reference/emr_track.addto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adds new records to a track — emr_track.addto","text":"","code":"emr_track.addto(track, src, force = FALSE)"},{"path":"/reference/emr_track.addto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adds new records to a track — emr_track.addto","text":"track track name src file name data-frame containing track records force 'TRUE', supresses user confirmation addition logical tracks","code":""},{"path":"/reference/emr_track.addto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adds new records to a track — emr_track.addto","text":"None.","code":""},{"path":"/reference/emr_track.addto.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Adds new records to a track — emr_track.addto","text":"function adds new records track. records contained either file data frame. 'src' file name, latter must constituted four columns separated spaces 'TAB' characters: ID, time, reference value. file might contain lines comments start '#' character. Note file contain header line. Alternatively 'src' can data frame consisting columns named \"id\", \"time\", \"ref\" \"value\". Note: \"ref\" column data frame optional. Adding logical track adds values underlying physical track, allowed values within logical track allowed values data frame src. Note might affect logical tracks pointing physical track therefore requires confirmation user unless force=TRUE.","code":""},{"path":[]},{"path":"/reference/emr_track.attr.export.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns attributes values of tracks — emr_track.attr.export","title":"Returns attributes values of tracks — emr_track.attr.export","text":"Returns attributes values tracks.","code":""},{"path":"/reference/emr_track.attr.export.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns attributes values of tracks — emr_track.attr.export","text":"","code":"emr_track.attr.export(track = NULL, attr = NULL)"},{"path":"/reference/emr_track.attr.export.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns attributes values of tracks — emr_track.attr.export","text":"track vector track names 'NULL' attr vector attribute names 'NULL'","code":""},{"path":"/reference/emr_track.attr.export.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns attributes values of tracks — emr_track.attr.export","text":"data frame containing attributes values tracks.","code":""},{"path":"/reference/emr_track.attr.export.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns attributes values of tracks — emr_track.attr.export","text":"function returns data frame contains attributes values one tracks. data frame constituted 3 columns named 'track', 'attr' 'value'. 'track' parameter optionally used retrieve attributes specific track(s). 'NULL', attributes tracks returned. Likewise 'attr' allows retrieve specifically named attributes. 'track' 'attr' used, attributes fulfill conditions returned.","code":""},{"path":[]},{"path":"/reference/emr_track.attr.export.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns attributes values of tracks — emr_track.attr.export","text":"","code":"emr_db.init_examples() emr_track.attr.export() #> [1] track attr  value #> <0 rows> (or 0-length row.names) emr_track.attr.set(\"sparse_track\", \"gender\", \"female\") emr_track.attr.set(\"sparse_track\", \"tag\", \"\") emr_track.attr.set(\"dense_track\", \"gender\", \"male\") emr_track.attr.export() #>          track   attr  value #> 1  dense_track gender   male #> 2 sparse_track gender female #> 3 sparse_track    tag        emr_track.attr.export(track = \"sparse_track\") #>          track   attr  value #> 1 sparse_track gender female #> 2 sparse_track    tag        emr_track.attr.export(attr = \"gender\") #>          track   attr  value #> 1  dense_track gender   male #> 2 sparse_track gender female emr_track.attr.export(track = \"sparse_track\", attr = \"gender\") #>          track   attr  value #> 1 sparse_track gender female"},{"path":"/reference/emr_track.attr.get.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the value of the track attribute — emr_track.attr.get","title":"Returns the value of the track attribute — emr_track.attr.get","text":"Returns value track attribute.","code":""},{"path":"/reference/emr_track.attr.get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the value of the track attribute — emr_track.attr.get","text":"","code":"emr_track.attr.get(track = NULL, attr = NULL)"},{"path":"/reference/emr_track.attr.get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the value of the track attribute — emr_track.attr.get","text":"track track name attr attribute name","code":""},{"path":"/reference/emr_track.attr.get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the value of the track attribute — emr_track.attr.get","text":"Track attribute value 'NULL'.","code":""},{"path":"/reference/emr_track.attr.get.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns the value of the track attribute — emr_track.attr.get","text":"function returns value track attribute 'NULL' attribute exist.","code":""},{"path":[]},{"path":"/reference/emr_track.attr.get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the value of the track attribute — emr_track.attr.get","text":"","code":"emr_db.init_examples() emr_track.attr.set(\"sparse_track\", \"test_attr\", \"value\") emr_track.attr.get(\"sparse_track\", \"test_attr\") #> [1] \"test_attr\""},{"path":"/reference/emr_track.attr.rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Deletes a track attribute — emr_track.attr.rm","title":"Deletes a track attribute — emr_track.attr.rm","text":"Deletes track attribute.","code":""},{"path":"/reference/emr_track.attr.rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deletes a track attribute — emr_track.attr.rm","text":"","code":"emr_track.attr.rm(track = NULL, attr = NULL)"},{"path":"/reference/emr_track.attr.rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deletes a track attribute — emr_track.attr.rm","text":"track track name attr attribute name","code":""},{"path":"/reference/emr_track.attr.rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deletes a track attribute — emr_track.attr.rm","text":"None.","code":""},{"path":"/reference/emr_track.attr.rm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deletes a track attribute — emr_track.attr.rm","text":"function deletes track attribute.","code":""},{"path":[]},{"path":"/reference/emr_track.attr.rm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deletes a track attribute — emr_track.attr.rm","text":"","code":"emr_db.init_examples() emr_track.attr.set(\"sparse_track\", \"test_attr\", \"value\") emr_track.attr.export() #>          track      attr  value #> 1  dense_track    gender   male #> 2 sparse_track    gender female #> 3 sparse_track test_attr  value emr_track.attr.rm(\"sparse_track\", \"test_attr\") emr_track.attr.export() #>          track   attr  value #> 1  dense_track gender   male #> 2 sparse_track gender female"},{"path":"/reference/emr_track.attr.set.html","id":null,"dir":"Reference","previous_headings":"","what":"Assigns a value to the track attribute — emr_track.attr.set","title":"Assigns a value to the track attribute — emr_track.attr.set","text":"Assigns value track attribute.","code":""},{"path":"/reference/emr_track.attr.set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns a value to the track attribute — emr_track.attr.set","text":"","code":"emr_track.attr.set(track = NULL, attr = NULL, value = NULL)"},{"path":"/reference/emr_track.attr.set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns a value to the track attribute — emr_track.attr.set","text":"track track name attr attribute name value value","code":""},{"path":"/reference/emr_track.attr.set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assigns a value to the track attribute — emr_track.attr.set","text":"None.","code":""},{"path":"/reference/emr_track.attr.set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assigns a value to the track attribute — emr_track.attr.set","text":"function creates track attribute assigns 'value' . attribute already exists value overwritten.","code":""},{"path":[]},{"path":"/reference/emr_track.attr.set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assigns a value to the track attribute — emr_track.attr.set","text":"","code":"emr_db.init_examples() emr_track.attr.set(\"sparse_track\", \"test_attr\", \"value\") emr_track.attr.get(\"sparse_track\", \"test_attr\") #> [1] \"test_attr\""},{"path":"/reference/emr_track.create.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a track from a track expression — emr_track.create","title":"Creates a track from a track expression — emr_track.create","text":"Creates track track expression.","code":""},{"path":"/reference/emr_track.create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a track from a track expression — emr_track.create","text":"","code":"emr_track.create(   track,   space,   categorical,   expr,   stime = NULL,   etime = NULL,   iterator = NULL,   keepref = F,   filter = NULL )"},{"path":"/reference/emr_track.create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a track from a track expression — emr_track.create","text":"track name newly created track space \"user\" \"global\" space categorical 'TRUE' track marked categorical expr track expression stime start time scope etime end time scope iterator track expression iterator. 'NULL' iterator determined implicitly based track expressions. See also 'iterator' section. keepref 'TRUE' references preserved iterator filter Iterator filter","code":""},{"path":"/reference/emr_track.create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a track from a track expression — emr_track.create","text":"None.","code":""},{"path":"/reference/emr_track.create.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates a track from a track expression — emr_track.create","text":"function creates new user global track based values track expression. location track controlled via 'space' parameter can either \"user\" \"global\".","code":""},{"path":"/reference/emr_track.create.html","id":"iterator","dir":"Reference","previous_headings":"","what":"iterator","title":"Creates a track from a track expression — emr_track.create","text":"types iterators: Track iterator: Track iterator returns points (including reference) specified track. Track name specified string. `keepref=FALSE` reference point set `-1`  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func=\"avg\", time.shift=1)  emr_extract(\"glucose\", iterator=\"insulin_shot_track\") Id-Time Points Iterator: Id-Time points iterator generates points *id-time points table*. `keepref=FALSE` reference point set `-1`.  Example:  # Returns level glucose one hour insulin shot made  emr_vtrack.create(\"glucose\", \"glucose_track\", func = \"avg\", time.shift = 1)  r <- emr_extract(\"insulin_shot_track\") # <-- implicit iterator used  emr_extract(\"glucose\", iterator = r) Ids Iterator: Ids iterator generates points ids taken *ids table* times run `stime` `etime` step 1. `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Example:  stime <- emr_date2time(1, 1, 2016, 0)  etime <- emr_date2time(31, 12, 2016, 23)  emr_extract(\"glucose\", iterator = data.frame(id = c(2, 5)), stime = stime, etime = etime) Time Intervals Iterator: *Time intervals iterator* generates points ids appear 'patients.dob' track times taken *time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`.  Example:  # Returns level hangover patients next day New Year Eve years 2015 2016  stime1 <- emr_date2time(1, 1, 2015, 0)  etime1 <- emr_date2time(1, 1, 2015, 23)  stime2 <- emr_date2time(1, 1, 2016, 0)  etime2 <- emr_date2time(1, 1, 2016, 23)  emr_extract(\"alcohol_level_track\", iterator = data.frame(      stime = c(stime1, stime2),      etime = c(etime1, etime2)  )) Id-Time Intervals Iterator: *Id-Time intervals iterator* generates id points cover `['stime', 'etime']` time range specified *id-time intervals table* (see: Appendix). time starts beginning time interval runs end step 1. said points lie outside `[stime, etime]` range skipped.  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1` Beat Iterator: *Beat Iterator* generates \"time beat\" given period id appear 'patients.dob' track. period given always hours.  Example:  emr_extract(\"glucose_track\", iterator=10, stime=1000, etime=2000)  create beat iterator period 10 hours starting `stime` `etime` reached. , example, `stime` equals `1000` beat iterator create id iterator points times: 1000, 1010, 1020, ...  `keepref=TRUE` id-time pair iterator generates 255 points references running `0` `254`. `keepref=FALSE` one point generated given id time, reference set `-1`. Extended Beat Iterator: *Extended beat iterator* name suggests variation beat iterator. works principle creating time points given period however instead basing times count `stime` accepts additional parameter - track *Id-Time Points table* - instructs initial time point ids. two parameters (period mapping) come list. id required appear certain id appear , skipped iterator.  Anyhow points lie outside `[stime, etime]` range generated.  Example:  # Returns maximal weight patients one year span starting birthdays  emr_vtrack.create(\"weight\", \"weight_track\", func = \"max\", time.shift = c(0, year()))  emr_extract(\"weight\", iterator = list(year(), \"birthday_track\"), stime = 1000, etime = 2000) Periodic Iterator: periodic iterator goes every year/month. can use running  emr_monthly_iterator emr_yearly_iterator.  Example:  iter <- emr_yearly_iterator(emr_date2time(1, 1, 2002), emr_date2time(1, 1, 2017))  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3)  iter <- emr_monthly_iterator(emr_date2time(1, 1, 2002), n = 15)  emr_extract(\"dense_track\", iterator = iter, stime = 1, etime = 3) Implicit Iterator: iterator set implicitly value remains `NULL` (default). case track expression analyzed searched track names. track variables virtual track variables point track, track used source track iterator. one track appears track expression, error message printed notifying ambiguity. Revealing Current Iterator Time: evaluation track expression one can access specially defined variable named `EMR_TIME` (Python: `TIME`). variable contains vector (`numpy.ndarray` Python) current iterator times. length vector matches length track variable (vector ).  Note values `EMR_TIME` might set 0. Skip intervals values track variables corresponding indices.  # Returns times current iterator day month  emr_extract(\"emr_time2dayofmonth(EMR_TIME)\", iterator = \"sparse_track\")","code":""},{"path":[]},{"path":"/reference/emr_track.exists.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks whether the track exists — emr_track.exists","title":"Checks whether the track exists — emr_track.exists","text":"Checks whether track exists.","code":""},{"path":"/reference/emr_track.exists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks whether the track exists — emr_track.exists","text":"","code":"emr_track.exists(track)"},{"path":"/reference/emr_track.exists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checks whether the track exists — emr_track.exists","text":"track track name","code":""},{"path":"/reference/emr_track.exists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks whether the track exists — emr_track.exists","text":"'TRUE' tracks exists, otherwise 'FALSE'","code":""},{"path":"/reference/emr_track.exists.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Checks whether the track exists — emr_track.exists","text":"function checks whether track exists.","code":""},{"path":[]},{"path":"/reference/emr_track.exists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Checks whether the track exists — emr_track.exists","text":"","code":"emr_db.init_examples() emr_track.exists(\"sparse_track\") #> [1] TRUE"},{"path":"/reference/emr_track.ids.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns track ids — emr_track.ids","title":"Returns track ids — emr_track.ids","text":"Returns ids contained track.","code":""},{"path":"/reference/emr_track.ids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns track ids — emr_track.ids","text":"","code":"emr_track.ids(track)"},{"path":"/reference/emr_track.ids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns track ids — emr_track.ids","text":"track track name","code":""},{"path":"/reference/emr_track.ids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns track ids — emr_track.ids","text":"Ids Table","code":""},{"path":"/reference/emr_track.ids.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns track ids — emr_track.ids","text":"Returns ids contained track. Note: function ignores current subset, .e. ids whole track returned.","code":""},{"path":[]},{"path":"/reference/emr_track.ids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns track ids — emr_track.ids","text":"","code":"emr_db.init_examples() emr_track.ids(\"categorical_track\") #>   id #> 1 24 #> 2 25 #> 3 27 #> 4 28"},{"path":"/reference/emr_track.import.html","id":null,"dir":"Reference","previous_headings":"","what":"Imports a track from a file or data-frame — emr_track.import","title":"Imports a track from a file or data-frame — emr_track.import","text":"Imports track file data-frame.","code":""},{"path":"/reference/emr_track.import.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Imports a track from a file or data-frame — emr_track.import","text":"","code":"emr_track.import(track, space, categorical, src)"},{"path":"/reference/emr_track.import.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Imports a track from a file or data-frame — emr_track.import","text":"track name newly created track space \"user\" \"global\" space categorical 'TRUE' track marked categorical src file name data-frame containing track records","code":""},{"path":"/reference/emr_track.import.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Imports a track from a file or data-frame — emr_track.import","text":"None.","code":""},{"path":"/reference/emr_track.import.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Imports a track from a file or data-frame — emr_track.import","text":"function creates new track text file data-frame. location track controlled via 'space' parameter can either \"user\" \"global\". 'src' file name, latter must constituted four columns separated spaces 'TAB' characters: ID, time, reference value. file might contain lines comments start '#' character. Alternatively 'src' can ID-Time Values table, data frame following columns: \"id\" \"time\" \"ref\" \"value\". Note file contain header. (see \"User Manual\" info).","code":""},{"path":[]},{"path":"/reference/emr_track.info.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns information about the track — emr_track.info","title":"Returns information about the track — emr_track.info","text":"Returns information track.","code":""},{"path":"/reference/emr_track.info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns information about the track — emr_track.info","text":"","code":"emr_track.info(track)"},{"path":"/reference/emr_track.info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns information about the track — emr_track.info","text":"track track name","code":""},{"path":"/reference/emr_track.info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns information about the track — emr_track.info","text":"list contains track properties","code":""},{"path":"/reference/emr_track.info.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns information about the track — emr_track.info","text":"function returns information track: type, data type, number vales, number unique values, minimal / maximal value, minimal / maximal id, minimal / maximal time. Note: function ignores current subset, .e. applied whole track.","code":""},{"path":[]},{"path":"/reference/emr_track.info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns information about the track — emr_track.info","text":"","code":"emr_db.init_examples() emr_track.info(\"sparse_track\") #> $path #> [1] \"/home/aviezerl/R/x86_64-pc-linux-gnu-library/4.0/naryn/naryndb/test/sparse_track.nrtrack\" #>  #> $type #> [1] \"sparse\" #>  #> $data.type #> [1] \"double\" #>  #> $categorical #> [1] FALSE #>  #> $num.vals #> [1] 21 #>  #> $num.unique.vals #> [1] 18 #>  #> $min.val #> [1] 10 #>  #> $max.val #> [1] 500 #>  #> $min.id #> [1] 5 #>  #> $max.id #> [1] 40 #>  #> $min.time #> [1] 1 #>  #> $max.time #> [1] 50 #>"},{"path":"/reference/emr_track.logical.create.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a logical track — emr_track.logical.create","title":"Creates a logical track — emr_track.logical.create","text":"Creates logical track","code":""},{"path":"/reference/emr_track.logical.create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a logical track — emr_track.logical.create","text":"","code":"emr_track.logical.create(track, src, values = NULL)"},{"path":"/reference/emr_track.logical.create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a logical track — emr_track.logical.create","text":"track one names newly created logical tracks. src name physical tracks logical track values vector selected values. creating multiple logical tracks - values list vectors (one vector values logical track).","code":""},{"path":"/reference/emr_track.logical.create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a logical track — emr_track.logical.create","text":"None.","code":""},{"path":"/reference/emr_track.logical.create.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates a logical track — emr_track.logical.create","text":"function creates logical track based existing categorical track global space.","code":""},{"path":"/reference/emr_track.logical.create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a logical track — emr_track.logical.create","text":"","code":"if (FALSE) { emr_track.logical.create(\"logical_track\", \"categorical_track\", values = c(2, 3))  # multiple tracks emr_track.logical.create(c(\"logical_track1\", \"logical_track2\"), rep(\"categorical_track\", 2), values = list(c(2, 3), c(1, 4))) }"},{"path":"/reference/emr_track.logical.rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Deletes a logical track — emr_track.logical.rm","title":"Deletes a logical track — emr_track.logical.rm","text":"Deletes logical track","code":""},{"path":"/reference/emr_track.logical.rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deletes a logical track — emr_track.logical.rm","text":"","code":"emr_track.logical.rm(track, force = FALSE, rm_vars = TRUE)"},{"path":"/reference/emr_track.logical.rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deletes a logical track — emr_track.logical.rm","text":"track name one tracks delete force 'TRUE', supresses user confirmation named track removal","code":""},{"path":"/reference/emr_track.logical.rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deletes a logical track — emr_track.logical.rm","text":"None.","code":""},{"path":"/reference/emr_track.ls.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns a list of track names — emr_track.ls","title":"Returns a list of track names — emr_track.ls","text":"Returns list track names database.","code":""},{"path":"/reference/emr_track.ls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns a list of track names — emr_track.ls","text":"","code":"emr_track.ls(   ...,   ignore.case = FALSE,   perl = FALSE,   fixed = FALSE,   useBytes = FALSE )  emr_track.global.ls(   ...,   ignore.case = FALSE,   perl = FALSE,   fixed = FALSE,   useBytes = FALSE )  emr_track.user.ls(   ...,   ignore.case = FALSE,   perl = FALSE,   fixed = FALSE,   useBytes = FALSE )  emr_track.logical.ls(   ...,   ignore.case = FALSE,   perl = FALSE,   fixed = FALSE,   useBytes = FALSE )"},{"path":"/reference/emr_track.ls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns a list of track names — emr_track.ls","text":"... arguments either form 'pattern' 'attribute = pattern' ignore.case, perl, fixed, useBytes see 'grep'","code":""},{"path":"/reference/emr_track.ls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns a list of track names — emr_track.ls","text":"array contains names tracks match supplied patterns.","code":""},{"path":"/reference/emr_track.ls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns a list of track names — emr_track.ls","text":"'emr_track.ls' returns list tracks (global user) database match pattern (see 'grep'). called without arguments tracks returned. pattern specified without track attribute (.e. form 'pattern') filtering applied track names. pattern supplied track attribute (.e. form 'name = pattern') track attribute matched pattern. Multiple patterns applied one another. resulted list tracks match patterns. 'emr_track.global.ls', 'emr_track.user.ls', 'emr_track.logical.ls' work similarly 'emr_track.ls' instead returning track names, returns either global, local logical tracks accordingly.","code":""},{"path":[]},{"path":"/reference/emr_track.ls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns a list of track names — emr_track.ls","text":"","code":"emr_db.init_examples()  # get all track names emr_track.ls() #> [1] \"categorical_track\" \"dense_track\"       \"patients.dob\"      #> [4] \"sparse_track\"       # get track names that match the pattern \"den*\" emr_track.ls(\"den*\") #> [1] \"dense_track\"  emr_track.attr.set(\"sparse_track\", \"gender\", \"female\") emr_track.attr.set(\"dense_track\", \"gender\", \"male\") emr_track.ls(gender = \"\") #> [1] \"dense_track\"  \"sparse_track\" emr_track.ls(gender = \"female\") #> [1] \"sparse_track\" emr_track.ls(gender = \"^male\") #> [1] \"dense_track\""},{"path":"/reference/emr_track.mv.html","id":null,"dir":"Reference","previous_headings":"","what":"Moves (renames) a track — emr_track.mv","title":"Moves (renames) a track — emr_track.mv","text":"Moves (renames) track","code":""},{"path":"/reference/emr_track.mv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Moves (renames) a track — emr_track.mv","text":"","code":"emr_track.mv(src, tgt, space = NULL)"},{"path":"/reference/emr_track.mv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Moves (renames) a track — emr_track.mv","text":"src source track name tgt target track name space \"global\" \"user\" 'NULL'","code":""},{"path":"/reference/emr_track.mv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Moves (renames) a track — emr_track.mv","text":"None.","code":""},{"path":"/reference/emr_track.mv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Moves (renames) a track — emr_track.mv","text":"function moves (renames) 'src' track 'tgt'. 'space' equals 'NULL', track remains space. Otherwise moved specified space. Note logical tracks moved user space.","code":""},{"path":[]},{"path":"/reference/emr_track.percentile.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns track percentile of the values — emr_track.percentile","title":"Returns track percentile of the values — emr_track.percentile","text":"Returns track percentile values.","code":""},{"path":"/reference/emr_track.percentile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns track percentile of the values — emr_track.percentile","text":"","code":"emr_track.percentile(track, val, lower = TRUE)"},{"path":"/reference/emr_track.percentile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns track percentile of the values — emr_track.percentile","text":"track track name val vector values lower calculate percentiles","code":""},{"path":"/reference/emr_track.percentile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns track percentile of the values — emr_track.percentile","text":"vector percentile values","code":""},{"path":"/reference/emr_track.percentile.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns track percentile of the values — emr_track.percentile","text":"function returns percentiles values given 'val' based track data. 'lower' 'TRUE' percentile indicates relative number track values lower 'val'. 'lower' 'FALSE' percentile reflects relative number track values lower equal 'val'.","code":""},{"path":[]},{"path":"/reference/emr_track.percentile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns track percentile of the values — emr_track.percentile","text":"","code":"emr_db.init_examples()  # percentiles of 30, 50 emr_track.percentile(\"dense_track\", c(30, 50)) #> [1] 0.45 0.50  # calculate percentiles of track's earliest values in time window emr_vtrack.create(\"v1\",     src = \"dense_track\", func = \"earliest\",     time.shift = c(-5, 5) ) emr_extract(c(     \"dense_track\",     \"emr_track.percentile(\\\"dense_track\\\", v1, FALSE)\" ), keepref = TRUE, names = c(\"col1\", \"col2\") ) #>    id time ref col1 col2 #> 1  22    1   3   13 0.20 #> 2  24    1   3   13 0.20 #> 3  25    1   0   10 0.05 #> 4  25    2   0   20 0.05 #> 5  25    2   2   22 0.05 #> 6  25    2   5   24 0.05 #> 7  25    2   6   26 0.05 #> 8  25    2   8   28 0.05 #> 9  25    3   4   34 0.05 #> 10 25    6   0   60 0.05 #> 11 25    6   2   62 0.05 #> 12 25    8   1   80 0.50 #> 13 25    8   4   84 0.50 #> 14 25    9   2   92 0.60 #> 15 25    9   4   94 0.60 #> 16 25   10   4  104 0.60 #> 17 25   12   4  124 0.70 #> 18 27   23   4  234 0.95 #> 19 27   50   0  500 1.00 #> 20 28    1   3   13 0.20"},{"path":"/reference/emr_track.readonly.html","id":null,"dir":"Reference","previous_headings":"","what":"Gets or sets ","title":"Gets or sets ","text":"Gets sets \"readonly\" property track.","code":""},{"path":"/reference/emr_track.readonly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gets or sets ","text":"","code":"emr_track.readonly(track, readonly = NULL)"},{"path":"/reference/emr_track.readonly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gets or sets ","text":"track track name readonly 'NULL', return \"readonlyness\" track, otherwise sets ","code":""},{"path":"/reference/emr_track.readonly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gets or sets ","text":"None.","code":""},{"path":"/reference/emr_track.readonly.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gets or sets ","text":"function gets sets \"read-onlyness\" track. 'readonly' 'NULL' functions retuns whether track R/O. Otherwise sets \"read-onlyness\" value indicated 'readonly'. Logical tracks inherit \"read-onlyness\" source physical tracks.","code":""},{"path":[]},{"path":"/reference/emr_track.rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Deletes a track — emr_track.rm","title":"Deletes a track — emr_track.rm","text":"Deletes track.","code":""},{"path":"/reference/emr_track.rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deletes a track — emr_track.rm","text":"","code":"emr_track.rm(track, force = F)"},{"path":"/reference/emr_track.rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deletes a track — emr_track.rm","text":"track track name force 'TRUE', supresses user confirmation named track removal","code":""},{"path":"/reference/emr_track.rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deletes a track — emr_track.rm","text":"None.","code":""},{"path":"/reference/emr_track.rm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deletes a track — emr_track.rm","text":"function deletes user track database. default 'emr_track.rm' requires user interactively confirm deletion. Set 'force' 'TRUE' suppress user prompt.","code":""},{"path":[]},{"path":"/reference/emr_track.unique.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns track values — emr_track.unique","title":"Returns track values — emr_track.unique","text":"Returns unique sorted track values","code":""},{"path":"/reference/emr_track.unique.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns track values — emr_track.unique","text":"","code":"emr_track.unique(track)"},{"path":"/reference/emr_track.unique.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns track values — emr_track.unique","text":"track track name","code":""},{"path":"/reference/emr_track.unique.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns track values — emr_track.unique","text":"vector values","code":""},{"path":"/reference/emr_track.unique.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns track values — emr_track.unique","text":"Returns unique sorted track values. NaN values (exist track) returned. Note: function ignores current subset, .e. unique values whole track returned.","code":""},{"path":[]},{"path":"/reference/emr_track.unique.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns track values — emr_track.unique","text":"","code":"emr_db.init_examples() emr_track.unique(\"categorical_track\") #> [1] 0 1 2 3 4"},{"path":"/reference/emr_track.var.get.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns value of a track variable — emr_track.var.get","title":"Returns value of a track variable — emr_track.var.get","text":"Returns value track variable.","code":""},{"path":"/reference/emr_track.var.get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns value of a track variable — emr_track.var.get","text":"","code":"emr_track.var.get(track, var)"},{"path":"/reference/emr_track.var.get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns value of a track variable — emr_track.var.get","text":"track track name var track variable name","code":""},{"path":"/reference/emr_track.var.get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns value of a track variable — emr_track.var.get","text":"Track variable value.","code":""},{"path":"/reference/emr_track.var.get.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns value of a track variable — emr_track.var.get","text":"function returns value track variable. variable exist error reported.","code":""},{"path":[]},{"path":"/reference/emr_track.var.get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns value of a track variable — emr_track.var.get","text":"","code":"emr_db.init_examples() emr_track.var.set(\"sparse_track\", \"test_var\", 1:10) emr_track.var.get(\"sparse_track\", \"test_var\") #>  [1]  1  2  3  4  5  6  7  8  9 10 emr_track.var.rm(\"sparse_track\", \"test_var\")"},{"path":"/reference/emr_track.var.ls.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns a list of track variables for a track — emr_track.var.ls","title":"Returns a list of track variables for a track — emr_track.var.ls","text":"Returns list track variables track.","code":""},{"path":"/reference/emr_track.var.ls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns a list of track variables for a track — emr_track.var.ls","text":"","code":"emr_track.var.ls(   track,   pattern = \"\",   ignore.case = FALSE,   perl = FALSE,   fixed = FALSE,   useBytes = FALSE )"},{"path":"/reference/emr_track.var.ls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns a list of track variables for a track — emr_track.var.ls","text":"track track name pattern, ignore.case, perl, fixed, useBytes see 'grep'","code":""},{"path":"/reference/emr_track.var.ls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns a list of track variables for a track — emr_track.var.ls","text":"array contains names track variables.","code":""},{"path":"/reference/emr_track.var.ls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns a list of track variables for a track — emr_track.var.ls","text":"function returns list track variables track match pattern (see 'grep'). called without arguments track variables track returned.","code":""},{"path":[]},{"path":"/reference/emr_track.var.ls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns a list of track variables for a track — emr_track.var.ls","text":"","code":"emr_db.init_examples() emr_track.var.ls(\"sparse_track\") #> character(0) emr_track.var.set(\"sparse_track\", \"test_var1\", 1:10) emr_track.var.set(\"sparse_track\", \"test_var2\", \"v\") emr_track.var.ls(\"sparse_track\") #> [1] \"test_var1\" \"test_var2\" emr_track.var.ls(\"sparse_track\", pattern = \"2\") #> [1] \"test_var2\" emr_track.var.rm(\"sparse_track\", \"test_var1\") emr_track.var.rm(\"sparse_track\", \"test_var2\")"},{"path":"/reference/emr_track.var.rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Deletes a track variable — emr_track.var.rm","title":"Deletes a track variable — emr_track.var.rm","text":"Deletes track variable.","code":""},{"path":"/reference/emr_track.var.rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deletes a track variable — emr_track.var.rm","text":"","code":"emr_track.var.rm(track, var)"},{"path":"/reference/emr_track.var.rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deletes a track variable — emr_track.var.rm","text":"track track name var track variable name","code":""},{"path":"/reference/emr_track.var.rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deletes a track variable — emr_track.var.rm","text":"None.","code":""},{"path":"/reference/emr_track.var.rm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deletes a track variable — emr_track.var.rm","text":"function deletes track variable.","code":""},{"path":[]},{"path":"/reference/emr_track.var.rm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deletes a track variable — emr_track.var.rm","text":"","code":"emr_db.init_examples() emr_track.var.set(\"sparse_track\", \"test_var1\", 1:10) emr_track.var.set(\"sparse_track\", \"test_var2\", \"v\") emr_track.var.ls(\"sparse_track\") #> [1] \"test_var1\" \"test_var2\" emr_track.var.rm(\"sparse_track\", \"test_var1\") emr_track.var.rm(\"sparse_track\", \"test_var2\") emr_track.var.ls(\"sparse_track\") #> character(0)"},{"path":"/reference/emr_track.var.set.html","id":null,"dir":"Reference","previous_headings":"","what":"Assigns value to a track variable — emr_track.var.set","title":"Assigns value to a track variable — emr_track.var.set","text":"Assigns value track variable.","code":""},{"path":"/reference/emr_track.var.set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Assigns value to a track variable — emr_track.var.set","text":"","code":"emr_track.var.set(track, var, value)"},{"path":"/reference/emr_track.var.set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Assigns value to a track variable — emr_track.var.set","text":"track track name var track variable name value value","code":""},{"path":"/reference/emr_track.var.set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Assigns value to a track variable — emr_track.var.set","text":"None.","code":""},{"path":"/reference/emr_track.var.set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Assigns value to a track variable — emr_track.var.set","text":"function creates track variable assigns 'value' . track variable already exists value overwritten.","code":""},{"path":[]},{"path":"/reference/emr_track.var.set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assigns value to a track variable — emr_track.var.set","text":"","code":"emr_db.init_examples() emr_track.var.set(\"sparse_track\", \"test_var\", 1:10) emr_track.var.get(\"sparse_track\", \"test_var\") #>  [1]  1  2  3  4  5  6  7  8  9 10 emr_track.var.rm(\"sparse_track\", \"test_var\")"},{"path":"/reference/emr_vtrack.attr.src.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set attributes of a virtual track — emr_vtrack.attr.src","title":"Get or set attributes of a virtual track — emr_vtrack.attr.src","text":"Get set attributes virtual track.","code":""},{"path":"/reference/emr_vtrack.attr.src.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set attributes of a virtual track — emr_vtrack.attr.src","text":"","code":"emr_vtrack.attr.src(vtrack, src)"},{"path":"/reference/emr_vtrack.attr.src.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set attributes of a virtual track — emr_vtrack.attr.src","text":"vtrack virtual track name. src, func, params, keepref, time.shift, id.map, filter virtual track attributes.","code":""},{"path":"/reference/emr_vtrack.attr.src.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set attributes of a virtual track — emr_vtrack.attr.src","text":"None.","code":""},{"path":"/reference/emr_vtrack.attr.src.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get or set attributes of a virtual track — emr_vtrack.attr.src","text":"'vtrack' argument used call, functions return corresponding attribute virtual track. Otherwise new attribute value set. Note: since inter-dependency exists certain attributes, correctness attributes whole can verified virtual track used track expression. information valid attribute values please refer documentation 'emr_vtrack.create'.","code":""},{"path":[]},{"path":"/reference/emr_vtrack.attr.src.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set attributes of a virtual track — emr_vtrack.attr.src","text":"","code":"emr_db.init_examples() emr_vtrack.create(\"vtrack1\", \"dense_track\") emr_vtrack.attr.src(\"vtrack1\") #> [1] \"dense_track\" emr_vtrack.attr.src(\"vtrack1\", \"sparse_track\") emr_vtrack.attr.src(\"vtrack1\") #> [1] \"sparse_track\""},{"path":"/reference/emr_vtrack.create.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a new virtual track — emr_vtrack.create","title":"Creates a new virtual track — emr_vtrack.create","text":"Creates new virtual track.","code":""},{"path":"/reference/emr_vtrack.create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a new virtual track — emr_vtrack.create","text":"","code":"emr_vtrack.create(   vtrack,   src,   func = NULL,   params = NULL,   keepref = F,   time.shift = NULL,   id.map = NULL,   filter = NULL )"},{"path":"/reference/emr_vtrack.create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a new virtual track — emr_vtrack.create","text":"vtrack virtual track name. src data source. func, params see . keepref see . time.shift time shift expansion iterator time. id.map id mapping. filter virtual track filter.","code":""},{"path":"/reference/emr_vtrack.create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a new virtual track — emr_vtrack.create","text":"Name virtual track (invisibly)","code":""},{"path":"/reference/emr_vtrack.create.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates a new virtual track — emr_vtrack.create","text":"function creates new virtual track named 'vtrack'. evaluation track expression contains virtual track 'vtrack' iterator point id-time (ID1, Time, Ref) form transformed first id-time interval: (ID2, Time1, Time2, Ref). 'id.map' 'NULL' ID1 == ID2, otherwise ID2 derived translation table provided 'id.map'. table data frame two first columns named 'id1' 'id2', 'id1' mapped 'id2'. 'id.map' contains also third optional column named 'time.shift' value V column used shift time accordingly, .e. Time1 = Time2 = Time + V. 'time.shift' parameter (confused 'time.shift' column 'id.map') can either single number X, case Time1 = Time2 = Time + X. Alternatively 'time.shift' can vector two numbers, .e. 'c(X1, X2)', result Time1 = Time + X1, Time2 = Time + X2. 'time.shift' parameter 'time.shift' column within 'id.map' may used simultaneously. case time shifts applied sequentially. next step values data source 'src' fall new id-time interval pass 'filter' collected. 'src' may either track name list two members: ID-Time Values table (see \"User Manual\") logical. logical 'TRUE', data table treated categorical, otherwise quantitative. 'keepref' 'TRUE' reference values must match 'ref' unless either reference 'ref' '-1'. Function 'func' ('params') applied collected values produces single value considered value 'vtrack' given iterator point. 'NULL' used value 'func', 'func' set implicitly 'value', data source categorical, 'avg', data source quantitative. Use following table reference valid functions parameters combinations. CATEGORICAL DATA SOURCE * 'vals' vector values. 'NULL' serves filter: function applied data source values appear among 'vals'. 'vals' can single NA value, case values track filtered . QUANTITATIVE DATA SOURCE * Percentile calculated based values whole data source even subset filter defined. Note: 'time.shift' can used 'keepref' 'FALSE'. Also 'keepref' 'TRUE' 'avg', 'percentile.upper' 'percentile.lower' can used 'func'.","code":""},{"path":[]},{"path":"/reference/emr_vtrack.create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates a new virtual track — emr_vtrack.create","text":"","code":"emr_db.init_examples()  emr_vtrack.create(\"vtrack1\", \"dense_track\",     time.shift = 1,     func = \"max\" ) emr_vtrack.create(\"vtrack2\", \"dense_track\",     time.shift = c(-5, 10), func = \"min\" ) res <- emr_extract(\"dense_track\", keepref = T, names = \"value\") emr_vtrack.create(\"vtrack3\", list(res, F),     time.shift = c(-5, 10),     func = \"min\" ) emr_extract(c(\"dense_track\", \"vtrack1\", \"vtrack2\", \"vtrack3\"),     keepref = T, iterator = \"dense_track\" ) #>    id time ref dense_track vtrack1 vtrack2 vtrack3 #> 1  22    1   3          13     NaN      13      13 #> 2  24    1   3          13     NaN      13      13 #> 3  25    1   0          10      28      10      10 #> 4  25    2   0          20      34      10      10 #> 5  25    2   2          22      34      10      10 #> 6  25    2   5          24      34      10      10 #> 7  25    2   6          26      34      10      10 #> 8  25    2   8          28      34      10      10 #> 9  25    3   4          34     NaN      10      10 #> 10 25    6   0          60     NaN      10      10 #> 11 25    6   2          62     NaN      10      10 #> 12 25    8   1          80      94      34      34 #> 13 25    8   4          84      94      34      34 #> 14 25    9   2          92     104      60      60 #> 15 25    9   4          94     104      60      60 #> 16 25   10   4         104     NaN      60      60 #> 17 25   12   4         124     NaN      80      80 #> 18 27   23   4         234     NaN     234     234 #> 19 27   50   0         500     NaN     500     500 #> 20 28    1   3          13     NaN      13      13"},{"path":"/reference/emr_vtrack.exists.html","id":null,"dir":"Reference","previous_headings":"","what":"Checks whether the virtual track exists — emr_vtrack.exists","title":"Checks whether the virtual track exists — emr_vtrack.exists","text":"Checks whether virtual track exists.","code":""},{"path":"/reference/emr_vtrack.exists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Checks whether the virtual track exists — emr_vtrack.exists","text":"","code":"emr_vtrack.exists(vtrack)"},{"path":"/reference/emr_vtrack.exists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Checks whether the virtual track exists — emr_vtrack.exists","text":"vtrack virtual track name","code":""},{"path":"/reference/emr_vtrack.exists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Checks whether the virtual track exists — emr_vtrack.exists","text":"'TRUE' virtual track exists, otherwise 'FALSE'.","code":""},{"path":"/reference/emr_vtrack.exists.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Checks whether the virtual track exists — emr_vtrack.exists","text":"function checks whether virtual track exists.","code":""},{"path":[]},{"path":"/reference/emr_vtrack.exists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Checks whether the virtual track exists — emr_vtrack.exists","text":"","code":"emr_db.init_examples() emr_vtrack.create(\"vtrack1\", \"dense_track\", c(5, 10), \"max\") #> Error: Function argument must be a string emr_vtrack.exists(\"vtrack1\") #> [1] TRUE"},{"path":"/reference/emr_vtrack.info.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns the definition of a virtual track — emr_vtrack.info","title":"Returns the definition of a virtual track — emr_vtrack.info","text":"Returns definition virtual track.","code":""},{"path":"/reference/emr_vtrack.info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns the definition of a virtual track — emr_vtrack.info","text":"","code":"emr_vtrack.info(vtrack)"},{"path":"/reference/emr_vtrack.info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns the definition of a virtual track — emr_vtrack.info","text":"vtrack virtual track name","code":""},{"path":"/reference/emr_vtrack.info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns the definition of a virtual track — emr_vtrack.info","text":"Internal representation virtual track.","code":""},{"path":"/reference/emr_vtrack.info.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns the definition of a virtual track — emr_vtrack.info","text":"function returns internal represenation virtual track.","code":""},{"path":[]},{"path":"/reference/emr_vtrack.info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns the definition of a virtual track — emr_vtrack.info","text":"","code":"emr_db.init_examples() emr_vtrack.create(\"vtrack1\", \"dense_track\", \"max\", time.shift = c(5, 10)) emr_vtrack.info(\"vtrack1\") #> $src #> [1] \"dense_track\" #>  #> $time_shift #> [1]  5 10 #>  #> $func #> [1] \"max\" #>  #> $params #> NULL #>  #> $keepref #> [1] FALSE #>  #> $id_map #> NULL #>  #> $filter #> NULL #>"},{"path":"/reference/emr_vtrack.ls.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns a list of virtual track names — emr_vtrack.ls","title":"Returns a list of virtual track names — emr_vtrack.ls","text":"Returns list virtual track names.","code":""},{"path":"/reference/emr_vtrack.ls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns a list of virtual track names — emr_vtrack.ls","text":"","code":"emr_vtrack.ls(   pattern = \"\",   ignore.case = FALSE,   perl = FALSE,   fixed = FALSE,   useBytes = FALSE )"},{"path":"/reference/emr_vtrack.ls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns a list of virtual track names — emr_vtrack.ls","text":"pattern, ignore.case, perl, fixed, useBytes see 'grep'","code":""},{"path":"/reference/emr_vtrack.ls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns a list of virtual track names — emr_vtrack.ls","text":"array contains names virtual tracks.","code":""},{"path":"/reference/emr_vtrack.ls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Returns a list of virtual track names — emr_vtrack.ls","text":"function returns list virtual tracks exist current R environment match pattern (see 'grep'). called without arguments virtual tracks returned.","code":""},{"path":[]},{"path":"/reference/emr_vtrack.ls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Returns a list of virtual track names — emr_vtrack.ls","text":"","code":"emr_db.init_examples() emr_vtrack.create(\"vtrack1\", \"dense_track\", func = \"max\") emr_vtrack.create(\"vtrack2\", \"dense_track\", func = \"min\") emr_vtrack.ls() #> [1] \"v1\"      \"vtrack1\" \"vtrack2\" \"vtrack3\" emr_vtrack.ls(\"*2\") #> [1] \"vtrack2\""},{"path":"/reference/emr_vtrack.rm.html","id":null,"dir":"Reference","previous_headings":"","what":"Deletes a virtual track — emr_vtrack.rm","title":"Deletes a virtual track — emr_vtrack.rm","text":"Deletes virtual track.","code":""},{"path":"/reference/emr_vtrack.rm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deletes a virtual track — emr_vtrack.rm","text":"","code":"emr_vtrack.rm(vtrack)"},{"path":"/reference/emr_vtrack.rm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deletes a virtual track — emr_vtrack.rm","text":"vtrack virtual track name","code":""},{"path":"/reference/emr_vtrack.rm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deletes a virtual track — emr_vtrack.rm","text":"None.","code":""},{"path":"/reference/emr_vtrack.rm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Deletes a virtual track — emr_vtrack.rm","text":"function deletes virtual track current R environment.","code":""},{"path":[]},{"path":"/reference/emr_vtrack.rm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deletes a virtual track — emr_vtrack.rm","text":"","code":"emr_db.init_examples() emr_vtrack.create(\"vtrack1\", \"dense_track\") emr_vtrack.create(\"vtrack2\", \"dense_track\") emr_vtrack.ls() #> [1] \"v1\"      \"vtrack1\" \"vtrack2\" \"vtrack3\" emr_vtrack.rm(\"vtrack1\") emr_vtrack.ls() #> [1] \"v1\"      \"vtrack2\" \"vtrack3\""},{"path":"/reference/naryn-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Toolkit for medical records data analysis — naryn-package","title":"Toolkit for medical records data analysis — naryn-package","text":"'naryn' package intended help users efficiently analyze data time-patient space.","code":""},{"path":"/reference/naryn-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Toolkit for medical records data analysis — naryn-package","text":"complete list help resources, use library(help = \"naryn\"). information options can found 'User manual' package.","code":""},{"path":"/news/index.html","id":"naryn-2-6-1","dir":"Changelog","previous_headings":"","what":"naryn 2.6.1","title":"naryn 2.6.1","text":"Added support logical tracks. emr_filter.create emr_vtrack.create now return silently name filter/vtrack. Allow addition entries id/time/values emr_track.addto. emr_dist emr_cor now dataframe parameter returns results tidy format. Bug fix: wrong results emr_dist right=FALSE values fraction. Added convenience time functions (emr_time, year, months etc). Support periodic iterators: emr_monthly_iterator, emr_yearly_iterator Use devtools ecosystem: roxygen documentation testthat tests. Added NEWS.md file track changes package.","code":""}]
