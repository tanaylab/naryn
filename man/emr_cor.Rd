% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract.R
\name{emr_cor}
\alias{emr_cor}
\title{Calculates correlation statistics for pairs of track expressions}
\usage{
emr_cor(
  ...,
  cor.exprs = NULL,
  include.lowest = FALSE,
  right = TRUE,
  stime = NULL,
  etime = NULL,
  iterator = NULL,
  keepref = F,
  filter = NULL,
  dataframe = FALSE,
  names = NULL
)
}
\arguments{
\item{cor.exprs}{vector of track expressions for which correlation
statistics is calculated.}

\item{include.lowest}{if 'TRUE', the lowest (or highest, for ‘right =
FALSE’) value of the range determined by breaks is included.}

\item{right}{if 'TRUE' the intervals are closed on the right (and open on
the left), otherwise vice versa.}

\item{stime}{start time scope.}

\item{etime}{end time scope.}

\item{iterator}{track expression iterator. If 'NULL' iterator is determined
implicitly based on track expressions.}

\item{keepref}{If 'TRUE' references are preserved in the iterator.}

\item{filter}{Iterator filter.}

\item{dataframe}{return a data frame instead of an N-dimensional vector.}

\item{names}{names for track expressions in the returned dataframe (only relevant when \code{dataframe == TRUE})}

\item{expr}{track expression.}

\item{breaks}{breaks that determine the bin or 'NULL'.}
}
\value{
A list of 5 elements each containing a N-dimensional vector (N is
the number of 'expr'-'breaks' pairs). The member of each vector is a
specific statistics matrix. If \code{dataframe == TRUE} - a data frame with a column for each track expression, additional columns i,j with pairs of \code{cor_exprs} and another 5 columns: 'n', 'e', 'var', 'cov', 'cor', see description.
}
\description{
Calculates correlation statistics for pairs of track expressions.
}
\details{
This function works in a similar manner to 'emr_dist'. However instead of
returning a single counter for each bin 'emr_cor' returns 5 matrices of
'length(cor.exprs) X length(cor.exprs)' size. Each matrix represents the
correlation statistics for each pair of track expressions from 'cor.exprs'.
Given a 'bin' and a pair of track expressions 'cor.exprs[i]' and
'cor.exprs[j]' the corresponding matrix contains the following information:

$n[bin,i,j] - number of times when both 'cor.exprs[i]' and 'cor.exprs[j]'
exist $e[bin,i,j] - expectation (average) of values from 'cor.exprs[i]' when
'cor.exprs[j]' exists $var[bin,i,j] - variance of values from 'cor.exprs[i]'
when 'cor.exprs[j]' exists $cov[bin,i,j] - covariance of 'cor.exprs[i]' and
'cor.exprs[j]' $cor[bin,i,j] - correlation of 'cor.exprs[i]' and
'cor.exprs[j]'

Similarly to 'emr_dist' 'emr_cor' can do multi-dimensional binning. Given N
dimensional binning the individual data in the matrices can be accessed as:
$cor[bin1, ..., binN, i, j].

If \code{dataframe == TRUE} the return value is a data frame with a column for each track expression, additional columns i,j with pairs of \code{cor_exprs}
and another 5 columns: 'n', 'e', 'var', 'cov', 'cor' with the same values
as the matrices described above.
}
\examples{

emr_db.init_examples()
emr_cor("categorical_track", c(0, 2, 5),
    cor.exprs = c("sparse_track", "1/dense_track"),
    include.lowest = T, iterator = "categorical_track",
    keepref = T
)
emr_cor("categorical_track", c(0, 2, 5),
    cor.exprs = c("sparse_track", "1/dense_track"),
    include.lowest = T, iterator = "categorical_track",
    keepref = T, 
    dataframe = TRUE
)
}
\seealso{
\code{\link{emr_dist}}, \code{\link{cut}},
\code{\link{emr_track.unique}}
}
\keyword{~correlation}
\keyword{~covariance}
\keyword{~variance}
