---
title: "naryn"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{naryn}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>"
)
options(tidyverse.quiet = TRUE)
```

```{r setup}
library(naryn)
library(tidyverse)
theme_set(theme_classic())
```

# Getting started with naryn

Naryn is an implmenetation of a time-series database, for efficient storage, retrieval and analysis of electronic health records (EHR).
The basic element of Naryn is a track - single numerical data element (e.g. RBC lab test result) that is recorded for many patients at various time points. A track can be thought of as a very sparse two-dimentional matrix with a row for each patient in the database, and a column for each hour.
The patient space is defined by a required track 'patients.dob' which must include all patients with a single timepoint at their time of birth.
Time reflects the difference in hours to 1/3/1867 00:00.

#### Connect to database


```{r}
emr_db.connect("/home/nettam/emr/sample_db")
```


```{r}
# show number of available tracks in database
length(emr_track.ls())
```


### Extract all patients in database

all patients must be listed in a track called 'patients.dob'. This track contains for each patient a single time point at the time of birth. In this mock database, the value per patient reflect their sex: 1 for male, 2 for female.


```{r}
patients <- emr_extract("patients.dob", names = "sex")
head(patients)
patients %>%
    count(sex) %>%
    mutate(sex = c("male", "female")[sex])
```


### Define virtual track for Age

In order to know the age of a patient at different event times we will calculate the difference between the time of the event 
and the time the patient was born as found in the patients.dob track. 
This is done by defining a virtual track, whereby the souce of the virtual track is patients.dob. 
A time window from the time of the event backwords in time (up to max age = 120 years) should capture the time the patient was born.
The difference in time is computed by the dt2.earliest function which computes the delta time (in hours) between the event time and the earliest appearance of a poin in the source track of the virtual track.



```{r}
emr_vtrack.create("age", "patients.dob", time.shift = c(-120 * 365 * 24, 0), func = "dt2.earliest")
```

### extract age and wbc test value, at time of test for each test performed in 2010


```{r}
emr_extract(c("age/(365*24)", "lab.WBC"), iterator = "lab.WBC", stime = emr_date2time(1, 1, 2010), etime = emr_date2time(1, 1, 2011), names = c("age", "wbc")) %>% head()
```

### Define virtual track for Survival - time until death

assume that patients.dod is a track with a single entry at most for each patient in the EHR database at time of death. 


```{r}
emr_vtrack.create("survival", "patients.dod", time.shift = c(0, 120 * 365 * 24), func = "dt1.earliest")
```

### Extract survival time for patients with pancreatic cancer


```{r}
# pancreatic cancer icd9 code is 157.9
# note that since icd9 diagnosis codes have a tree like structure, and X.0, X.00 are both valid codes and must be distinguishable,
# the diagnosis tracks all include a prefix of 1 for the minor code, so X.0 will be translated to icd9_X and a value of 10 will be stored.

# define a filter for just Pancreatic cancer in the 157 icd9 code.
emr_filter.create("pancreatic_cancer", "dx.icd9_157", val = 19)
# define a filter for previous pancreatic cancer (sometime in the past).
emr_filter.create("pancreatic_cancer_in_past", "dx.icd9_157", val = 19, time.shift = c(-120 * 365 * 24, -1))

# to find the first diagnosis of pancreatic cancer we will go over all 157 diagnosis, filter out those that are not pancreatic cancer and make sure there wasn't a prior diagnosis of pancreatic cancer
pancreatic_cancer_survival <- emr_extract("survival", iterator = "dx.icd9_157", filter = "pancreatic_cancer & !pancreatic_cancer_in_past")
nrow(pancreatic_cancer_survival)
head(pancreatic_cancer_survival)

# note that NA in survival means that the patient still has not died
```


```{r}
# kaplan meier for survival of pancreatic cancer patients
# censoring is applied to reflect latest update of database (Jan 6, 2022)
pancreatic_cancer_survival <- pancreatic_cancer_survival %>%
    mutate(
        follow_time = ifelse(!is.na(survival), survival, emr_date2time(6, 1, 2022) - time),
        status = ifelse(is.na(survival), 0, 1)
    )
```


```{r}
# fitting survival curve
library(survminer)
library(survival)
fit <- survminer::surv_fit(survival::Surv(follow_time, status) ~ 1, data = pancreatic_cancer_survival)
survminer::ggsurvplot(fit, data = pancreatic_cancer_survival)
```



### Extract HGB and age for all patients between the ages 60 and 70

```{r}
# create an age filter. If we go over a BMI test value for a patient, then we expect there to be a date of birth entry between 70 and 60 years before. This would mean that the patient is in the required age range
emr_filter.create("age_60_70", "patients.dob", time.shift = c(-70, -60) * 365 * 24)
hgb_60_70 <- emr_extract(c("age/(24*365)", "lab.HGB"), iterator = "lab.HGB", filter = "age_60_70", names = c("age", "hgb"))
```


```{r}
ggplot(hgb_60_70 %>% mutate(age = floor(age)) %>% count(age), aes(x = age, y = n)) +
    geom_bar(stat = "identity")
ggplot(hgb_60_70, aes(x = hgb)) +
    geom_density()
```


```{r}
# adding sex information as hgb has bimodal distribution
# sex is encoded in the patients.dob track, 1 for male and 2 for female
emr_vtrack.create("sex", "patients.dob", time.shift = c(-120 * 365 * 24, 0), func = "earliest")
hgb_sex_60_70 <- emr_extract(c("age/(24*365)", "sex", "lab.HGB"), iterator = "lab.HGB", filter = "age_60_70", names = c("age", "sex", "hgb")) %>%
    mutate(sex = factor(c("male", "female")[sex]))
```


```{r}
ggplot(hgb_sex_60_70 %>% mutate(age = floor(age)) %>% count(age, sex), aes(x = age, y = n, fill = sex)) +
    geom_bar(stat = "identity")
ggplot(hgb_sex_60_70, aes(x = hgb, color = sex, group = sex)) +
    geom_density()
```



### Extract patients age at time of diagnosis of heart disease (diagnosis.411)  that did not have diabetes (diagnosis.250)


```{r}
# find onset of heart disease
emr_vtrack.create("heart_onset", "dx.icd9_411", time.shift = c(0, 120 * 365 * 24), func = "earliest.time")
emr_filter.create("has_heart_disease", "dx.icd9_411", time.shift = c(0, 120 * 365 * 24))
# retrieving the earliest time of heart disease for all patients in db that have a heart disease
heart_onset <- emr_extract("heart_onset", iterator = "patients.dob", filter = "has_heart_disease")
```


```{r}
# filter patients that already have diabetes before heart disease
emr_filter.create("has_diabetes", "dx.icd9_250", time.shift = c(-120 * 365 * 24, 0))
heart_onset_no_diabetes <- emr_extract("age/(365*24)", iterator = heart_onset %>% select(id, time = heart_onset), filter = "!has_diabetes", names = "age")
```


```{r}
nrow(heart_onset)
nrow(heart_onset_no_diabetes)
```


```{r}
head(heart_onset_no_diabetes)
```


### Extract median Hemoglobin for all males between ages 60 to 70


```{r}
# define vtrack for computing the median value of hgb track, assuming patients.dob will be used as the iterator (each patient will be examined once)
emr_vtrack.create("median_hgb", "lab.HGB", time.shift = c(60, 70) * 365 * 24, func = "quantile", params = c(0.5))
```


```{r}
# define a filter for males only
emr_filter.create("is_male", "patients.dob", time.shift = c(0, 0), val = 1)
```


```{r}
# extract median_hgb for males only
male_hgb_60_70_q50 <- emr_extract("median_hgb", iterator = "patients.dob", filter = "is_male")
```


```{r}
# comparing with female median hgb
female_hgb_60_70_q50 <- emr_extract("median_hgb", iterator = "patients.dob", filter = "!is_male")
```


```{r}
plot(density(male_hgb_60_70_q50$median_hgb, na.rm = T), col = "blue", main = "median hgb")
lines(density(female_hgb_60_70_q50$median_hgb, na.rm = T), col = "red")
```

### Compute distribution of HGB by age and sex


```{r}
hgb_dist <- emr_dist("age/(24*365)", c(20, 50, 90),
    "sex", NULL,
    "lab.HGB", seq(10, 16, by = 0.5),
    iterator = "lab.HGB",
    dataframe = TRUE,
    names = c("age", "sex", "hgb"),
    right = FALSE
)
head(hgb_dist)
```

```{r}
ggplot(hgb_dist %>% mutate(sex = factor(c("male", "female")[sex])), aes(x = hgb, y = n, colour = age, group = age)) +
    geom_line() +
    facet_wrap(~sex) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```


```{r}
### Count number of patients by age that are in the system in january 2020
```


```{r}
# patients in the system must have already been born, have not yet died, registered with the EHR system and that haven't left for good
emr_filter.create("born", "patients.dob", time.shift = c(-120 * 365 * 24, 0))
emr_filter.create("dead", "patients.dod", time.shift = c(-120 * 365 * 24, 0))
emr_filter.create("registered", "patients.status.register", time.shift = c(-120 * 365 * 24, 0))
emr_filter.create("left_for_good", "patients.status.lfg", time.shift = c(-120 * 365 * 24, 0))

age_dist_2020 <- emr_dist("age/(365*24)", 0:120, "sex", NULL,
    iterator = 1,
    stime = emr_date2time(1, 1, 2020),
    etime = emr_date2time(1, 1, 2020),
    filter = "born & !dead & registered & !left_for_good",
    names = c("age", "sex"),
    dataframe = TRUE,
    right = FALSE
)
head(age_dist_2020 %>% filter(n > 0))
```


```{r}
options(repr.plot.width = 20)
age_dist_2020 %>%
    mutate(sex = factor(c("male", "female")[sex])) %>%
    ggplot(aes(x = age, y = n, colour = sex, fill = sex, group = sex)) +
    geom_bar(stat = "identity") +
    facet_wrap(~sex) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```
