%\VignetteIndexEntry{User manual}

\documentclass{article}

\usepackage{amsmath}
\usepackage{amscd}
\usepackage[tableposition=top]{caption}
\usepackage{ifthen}
\usepackage[utf8]{inputenc}
\usepackage[dvips]{epsfig,psfrag}
\usepackage{listings}
\usepackage[margin=1in]{geometry} % 1 inch margins all around

\begin{document}
\SweaveOpts{concordance=TRUE}

\title{Package 'naryn' - User Manual}
\maketitle

'naryn' package that helps to efficiently analyze medical records data.

\tableofcontents

\newpage

\section{Database}

Naryn allows to access data that resides in \emph{tracks} where each track holds certain type of medical data such as patients' diagnoses or their hemoglobin level at certain points of time. The track files are aggregated in a directory. Before the tracks can be accessed, Naryn needs to establish connection to this directory, also referred as a \emph{global root} or \emph{global space root}. Call \texttt{emr\_db.init} function to establish the access to the tracks in the global root directory. Optionally \texttt{emr\_db.init} accepts an additional \emph{user root} (or \emph{user space root}) directory which can also constains additional tracks.

Even though both global and user root directories may contain track files their designation is different. The global root directory is intended to stay mainly read-only with a notable exception of periodic updates to the existing data which can be performed via \texttt{emr\_track.addto} function. No tracks are allowed to be deleted from the global root directory. Unlike that user root directory is intended to store volatile data like the results of intermediate calculations. New tracks can be created in both user or global space using \texttt{emr\_track.import} or \texttt{emr\_track.create} yet the creation of tracks in the global space is strongly discouraged.

Once \texttt{emr\_db.init} is successfully called a few auxiliary variables are added to R global environment. Please refer the documentation of this function.

\subsection{Tracks}

Each track is stored in a binary file with \emph{.nrtrack} file extention. One of the two internal formats, \emph{dense} or \emph{sparse}, is automatically selected during the track creation. The choice of the exact format is based on the optimal run-time performance.

\subsubsection{Records and References}

\emph{Track} is a data structure that stores a set of records of \texttt{(id, time, ref, numeric value}) type. For example, hemoglobin level of patients can be stored in this way, where \texttt{id} would be the id of the patient and \emph{time} would indicate the moment when the blood test was made. Another track can contain the code of the laboratory which carried out the test. If the times of the records from the two tracks match, one would conclude which lab performed the given test.

Time resolution is always in hours. It might happen that two different blood tests are  carried out by two different labs for the same patient at the same hour. Assuming that each lab has certain bias due to different equipment used, the reads of the hemoglobin might come out different. Since both of the tests are carried out at exactly the same hour it will be impossible later to link each result to the lab that performed it.

In the situations when two or more values share identical \texttt{id} and \texttt{time} Naryn requires them to use then different \texttt{ref} (\emph{references}). Reference is an integer number in the range of [-1, 254], which when no time collision occurs is normally set to -1. However in cases of ambiguity it can give additional resolution to the time. In our blood example the results of the first lab could have been recorded with \texttt{ref = 0} wherever the second lab would do it with \texttt{ref = 1}. This way the two hemoglobin readings could later be separated and correctly linked to their originating labs.

\subsubsection{Categorial and Quantitative Tracks}

Tracks store numerical values assigned to the patients and times. The numerical data however can have different meaning and hence impose different set of operations to be applied to it. Laboratory codes, diagnosis codes, binary information such as date of birth or doctor visits are one type of data which we call \emph{categorial}. Another type of data indicate usually the readings of different instruments such as the heartbeat rate or glucose level. This type of data is called \emph{quantitative}.

The operations that can be applied to both of these types can be very different. One might want to search for the specific diagnosis code, yet it makes little sense to search for the very specific heartbeat rate, say "68". On contrary hearbeat rate readings from different times can be averaged or a mean value might be calculated - something that has no meaning in case of categorial data.

During the track creation one must specify the type of the track: categorial or quantitative. Various operations that can be later applied to the track are bound to the track type.

\subsubsection{Track Variables}

Track statistics, results of time-consuming per-track calculations, historical data and any other data in arbitrary format can be stored in a track's supplementary data in the form of track variables. Track variable can be retrieved, added, modified or deleted using \texttt{emr\_track.var.get}, \texttt{emr\_track.var.set}, \texttt{emr\_track.var.rm} functions. List of track variables can be retrieved using \texttt{emr\_track.var.ls} function.

\subsubsection{Subsets}

The analysis of data often involves dividing the data to train and test sets. 
Naryn allows to subset the data via \texttt{emr\_db.subset} function. \texttt{emr\_db.subset} accepts a list of ids or samples the ids randomally. These ids constitute the subset. The ids that are not in the subset are skipped by all the \emph{iterators}, \emph{filters} and various functions.

One may think of a subset as an additonal layer, a "viewport", that filters out some of the ids. Some lower-level functions such as \texttt{emr\_track.info} or \texttt{emr\_track.unique} ignore the subsets. Same applies to \texttt{percentile.*} functions of the virtual tracks. The constant \texttt{MINTIME}, \texttt{MAXTIME}, \texttt{MINID} and \texttt{MAXID} are also defined based on the whole set of ids regardless of the current subset.

\section{Accessing the Data}

\subsection{Track Expressions}

\subsubsection{Introduction}

\emph{Track expression} allows to retrieve numerical data that is recorded in the tracks. Track expressions are widely used in various functions (\texttt{emr\_screen}, \texttt{emr\_extract}, \texttt{emr\_dist}, ...).

Track expression is a character string that closely resembles a valid R expression. Just like any other R expression it may include conditions, function calls and variables defined beforehand. \texttt{"1 > 2"}, \texttt{"mean(1:10)"} and \texttt{"myvar < 17"} are all valid track expressions. Unlike regular R expressions track expression might also contain track names and / or \emph{virtual track} names.

To understand how the track expression allows the access to the tracks we must explain how the track expression gets evaluated.

Every track expression is accompanied by an \emph{iterator} that produces a set of \emph{id-time points} of \texttt{(id, time, ref)} type. For each each iterator point the track expression is evaluated. The value of the track expression \texttt{"mean(1:10)"} is constant regardless the iterator point. However the track expression might contain a track name \texttt{mytrack}, like: \texttt{"mytrack * 3"}. Naryn recognizes then that \texttt{mytrack} is not a regular R variable but rather a track name. A new R variable named \texttt{mytrack} is added then to R environment. For each iterator point this variable is assigned the value of the track that matches \texttt{(id, time, ref)} (or NaN if no matching value exists in the track). Once \texttt{mytrack} is assigned the corresponding value, the track expression is evaluated in R.

\subsubsection{Matching Reference in the Track Expression}

If the track expression contains a track (or virtual track) name, then the values from the track are fetched one-by-one into the identically named R variable based on \texttt{id}, \texttt{time} and \texttt{ref} of the iterator point. If however \texttt{ref} of the iterator point equals to \texttt{-1}, we treat it as a "wildcard": matching is required then only for \texttt{id} and \texttt{time}.

"Wildcard" reference in the iterator might create a new issue: more than one track value might match then a single iterator point. In this case the value placed in the track variable (e.g. \texttt{mytrack}) depends on the type of the track. If the track is categorial the track variable is set to \texttt{-1}, otherwise it is set to the average of all matching values.

\subsubsection{Virtual Tracks}

So far we have shown that in some situations \texttt{mytrack} variable can be set to the average of the matching track values. But what if we do not want to average the values but rather pick up the maximal, minimal or median value? What if we want to use the percentile of a track value rather than the value itself? And maybe we even want to alter the time of the iterator point: shift it or expand to a time window and by that look at the different set of track values? For instance: given an iterator point we might want to know what was the maximal level of glucose during the last year that preceeded the time of the point.

This is where virtual tracks come in use.

Virtual track is a named set of rules that describe how the track should be proceeded, and how the time of the iterator point should be modified. Virtual tracks are created by \texttt{emr\_vtrack.create} function:

\begin{verbatim}
emr_vtrack.create("annual_glucose", src="glucose_track", func="quantile",
                  param=0.5, time.shift=c(-365*24, 0))
\end{verbatim}

This call creates a new virtual track named \texttt{annual\_glucose} based on the underlying physical \emph{source track} \texttt{glucose\_track}. For each iterator point with time \texttt{T} we look at values of \texttt{glucose\_track} in the time window of \texttt{[T-365*24,T]}, i.e. one year prior to \texttt{T}. We calculate then the median over the values (\texttt{func="quantile"}, \texttt{param=0.5}).

There is a rich set of various functions besides "quantile" that can be applied to the track values. Some of these functions can be used only with categorial tracks, other ones - only with quantitative tracks and some functions can be applied to both types of the track. Please refer the documentation of \texttt{emr\_vtrack.create}.

Once a virtual track is created it can be used in a track expression:
\begin{verbatim}
emr_extract("annual_glucose", iterator=list(365*24, ‘date_of_birth_track’))
\end{verbatim}

This would give us a median of an annual glucose level in year-steps starting from the patient's birthday. (This example makes use of an \emph{Extended Beat Iterator} that would be expalained later.)

Let's expand our example further and ignore in our calculations the glucose readings that had been made within a week after steroids had been prescribed. We can use an additional \texttt{filter} parameter to do that.

\begin{verbatim}
emr_filter.create("steroids_filter", "steroids_track", time.shift=c(-24*7, 0))
emr_vtrack.create("annual_glucose", src="glucose_track", func="quantile",
                  param=0.5, time.shift=c(-365*24,0), filter="!steroids_filter")
emr_extract("annual_glucose", iterator=list(365*24, ‘date_of_birth_track’))
\end{verbatim}

\emph{Filter} is applied to the ID-Time points of the source track (e.g. \texttt{glucose\_track} in our example). The virtual track function (\texttt{quantile}, ...) is applied then only to the points that pass the filter. The concept of filters is explained extensively in a separate chapter.

Virtual tracks allow also to remap the patient ids. This is done via \texttt{id.map} parameter which accepts a data frame that defines the id mapping. Remapping ids might be useful if family ties are explored. For example, instead of glucose level of the patient we are interested to check the glucose level of one of his family members.

\subsection{Iterators}

So far we have discussed the track expressions and how they are evaluated given the iterator point. In this section we will show how the iterator points are generated.

An iterator is defined via \texttt{iterator} parameter. There are a few types of iterators such as \emph{track iterator}, \emph{beat iterator}, etc. The type determines which points are generated by the iterator. The information about each type is listed below.

Iterator is always accompanied by four additional parameters: \texttt{stime}, \texttt{etime}, \texttt{keepref} and \texttt{filter}. \texttt{stime} and \texttt{etime} bind the time scope of the iterator: the points that the iterator generates lie always within these boundaries. The effect of \texttt{keepref=T} depends on the iterator type. However for all the iterator types if \texttt{keepref=F} the reference of all the iterator points is set to \texttt{-1}. \texttt{filter} parameter sets the iterator filter which is discussed thoroughly later in the document in a separate chapter.

\subsubsection{Track Iterator}

\emph{Track iterator} returns the points (including the reference) from the specified track. Track name is specified as a string.

If \texttt{keepref=F} the reference of each point is set to \texttt{-1}.

Example:

\begin{verbatim}
# Returns the level of glucose one hour after the insulin shot was made
emr_vtrack.create("glucose", "glucose_track", func="avg", time.shift=1)
emr_extract("glucose", iterator="insulin_shot_track")
\end{verbatim}

\subsubsection{Id-Time Points Iterator}

\emph{Id-Time points iterator} generates points from an \emph{id-time points table} (see: Appendix). If \texttt{keepref=F} the reference of each point is set to \texttt{-1}.

Example:

\begin{verbatim}
# Returns the level of glucose one hour after the insulin shot was made
emr_vtrack.create("glucose", "glucose_track", func="avg", time.shift=1)
r <- emr_extract("insulin_shot_track")  # <-- implicit iterator is used here
emr_extract("glucose", iterator=r)
\end{verbatim}

\subsubsection{Ids Iterator}

\emph{Ids iterator} generates points with ids taken from an \emph{ids table} (see: Appendix) and times that run from \texttt{stime} to \texttt{etime} with a step of 1.

If \texttt{keepref=T} for each id-time pair the iterator generates 255 points with references running from \texttt{0} to \texttt{254}. If \texttt{keepref=F} only one point is generated for the given id and time, and its reference is set to \texttt{-1}.

Example:

\begin{verbatim}
# Returns the level of glucose for each hour in year 2016 for ids 2 and 5
stime <- emr_date2time(1, 1, 2016, 0)
etime <- emr_date2time(31, 12, 2016, 23)
emr_extract("glucose", iterator=data.frame(id=c(2,5)), stime=stime, etime=etime)
\end{verbatim}

\subsubsection{Time Intervals Iterator}

\emph{Time intervals iterator} generates points for all the ids in the range of \texttt{[MINID, MAXID]} with times taken from a \emph{time intervals table} (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of \texttt{[stime, etime]} range are skipped.

\texttt{MINID} and \texttt{MAXID} are the minimal and the maximal ids existing in the database.

If \texttt{keepref=T} for each id-time pair the iterator generates 255 points with references running from \texttt{0} to \texttt{254}. If \texttt{keepref=F} only one point is generated for the given id and time, and its reference is set to \texttt{-1}.

Example:

\begin{verbatim}
# Returns the level of hangover for all patients the next day after New Year Eve
# for the years 2015 and 2016
stime1 <- emr_date2time(1, 1, 2015, 0)
etime1 <- emr_date2time(1, 1, 2015, 23)
stime2 <- emr_date2time(1, 1, 2016, 0)
etime2 <- emr_date2time(1, 1, 2016, 23)
emr_extract("alcohol_level_track", iterator=data.frame(stime=c(stime1, stime2),
            etime=c(etime1, etime2)))
\end{verbatim}

\subsubsection{Id-Time Intervals Iterator}

\emph{Id-Time intervals iterator} generates for each id points that cover \texttt{['stime', 'etime']} time range as specified in \emph{id-time intervals table} (see: Appendix). Each time starts at the beginning of the time interval and runs to the end of it with a step of 1. That being said the points that lie outside of \texttt{[stime, etime]} range are skipped.

If \texttt{keepref=T} for each id-time pair the iterator generates 255 points with references running from \texttt{0} to \texttt{254}. If \texttt{keepref=F} only one point is generated for the given id and time, and its reference is set to \texttt{-1}.

\subsubsection{Beat Iterator}

\emph{Beat Iterator} generates a "time beat" at the given period for each existing patient id. The period is given always in hours.

Example:

\begin{verbatim}
emr_extract("glucose_track", iterator=10)
\end{verbatim}

This will create a beat iterator with a period of 10 hours starting at \texttt{stime} (default: \texttt{MINTIME}) up until \texttt{etime} (default: \texttt{MAXTIME}) is reached. If, for example, \texttt{stime} equals \texttt{1000} then the beat iterator will create for each id iterator points at times: 1000, 1010, 1020, ...

If \texttt{keepref=T} for each id-time pair the iterator generates 255 points with references running from \texttt{0} to \texttt{254}. If \texttt{keepref=F} only one point is generated for the given id and time, and its reference is set to \texttt{-1}.

\subsubsection{Extended Beat Iterator}

\emph{Extended beat iterator} is as its name suggests a variation on the beat iterator. It works by the same principle of creating time points with the given period however instead of basing the times count on \texttt{stime} it accepts an additional parameter - a track or a \emph{Id-Time Points table} - that instructs what should be the initial time point for each of the ids. The two parameters (period and mapping) should come in a list. Each id is required to appear only once and if a certain id does not appear at all, it is skipped by the iterator.

Anyhow points that lie outside of \texttt{[stime, etime]} range are not generated.

Example:

\begin{verbatim}
# Returns the maximal weight of patients at one year span starting from their birthdays
emr_vtrack.create("weight", "weight_track", func="max", time.shift=c(0, 24*365))
emr_extract("weight", iterator=list(24*365, "birthday_track"))
\end{verbatim}

\subsubsection{Implicit Iterator}

The iterator is set implicitly if its value remains \texttt{NULL} (which is the default). In that case the track expression is analyzed and searched for track names. If all the track variables or virtual track variables point to the same track, this track is used as a source for a track iterator. If more then one track appears in the track expression, an error message is printed out notifying ambiguity.

\subsubsection{Revealing Current Iterator Time}

During the evaluation of a track expression one can access a specially defined variable named \texttt{EMR\_TIME}. This variable contains a vector of current iterator times. The length of the vector matches the length of the track variable (which is a vector too).

Note that some values in \texttt{EMR\_TIME} might be set 0. Skip those intervals and the values of the track variables at the corresponding indices.

\begin{verbatim}
# Returns times of the current iterator as a day of month
emr_extract("emr_time2dayofmonth(EMR_TIME)", iterator = "sparse_track")
\end{verbatim}

\subsection{Filters}

\emph{Filter} is used to approve / reject an ID-Time point. It can be applied to an iterator, in which case the iterator points are required to be approved by the filter before they are passed further to the track expression. Filter may also be used by a virtual track. In this case the virtual track function (see \texttt{func} parameter of \texttt{emr\_vitrack.create}) is applied only to the points from the source track (\texttt{src} parameter) that pass the filter.

Filter has a form of a logical expression consisting of \emph{named} or \emph{unnamed} \emph{elementary filters} (the "building bricks" of the filter) connected with the logical operators: \texttt{\&}, \texttt{|}, \texttt{!} and brackets \texttt{()}.

\subsubsection{Named Filters}

Suppose we are interested in hemoglobin levels of patients who were prescribed either drugX or drugY but not drugZ within a time window of one week before the test. Assume that drugX, drugY and drugZ are residing each in its separate track. Without filters we would need to call \texttt{emr\_extract} four times, store potentially huge data frame results in the memory and finally merge the tables within R while caring about time windows. With filters we can do it much easier:

\begin{verbatim}
emr_filter.create("filterX", "drugX", time.shift = c(24 * 7, 0))
emr_filter.create("filterY", "drugY", time.shift = c(24 * 7, 0))
emr_filter.create("filterZ", "drugZ", time.shift = c(24 * 7, 0))
emr_extract("hemoglobin", filter = "(filterX | filterY) & !filterZ")
\end{verbatim}

Each call to \texttt{emr\_filter.create} creates a \emph{named elementary filter} (or simply: named filter) with a unique name. The named filter can then be used in \texttt{filter} parameter of an iterator and be combined with other named filters using the logical operators.

\subsubsection{Other Objects within Filters}

In our previous example we created three named filters based on three tracks. If time window was not required, we could have used the names of the tracks directly in the filter, like: \texttt{filter = "(drugX | drugY) \& !drugZ"}.

In addition to track names other types of objects can be used within the filter. These are: \emph{Id-Time Points Table}, \emph{Ids Table}, \emph{Time Intervals Table} and \emph{Id-Time Intervals Table} (see \emph{Appendix} for the format of these tables). When used in the filter the object should be constructed in advanced and be referred by its name. "In place" construction (aka: \texttt{filter = "data.frame(...)"} is not allowed.

\subsubsection{Managing Reference in Filters}

The ID-Time Point embeds within itself a reference value. Named filters allow to specify whether the reference should be used for matching or not. When \texttt{keepref=TRUE} is set within \texttt{emr\_filter.create}, the candidate point's reference is matched with the filter's reference. Otherwise the references are ignored.

It is important to remember that references are always ignored when any object but a named filter is used within a filter. For instance, if \texttt{filter = "drug"} and \texttt{drug} is a name of a track (and not a name of a named filter), then the references will be ignored during the matching. To ensure the filter matches the references of \texttt{drug} track, one must define a named filter with \texttt{keepref=TRUE} parameter:

\begin{verbatim}
emr_filter.create("drug_filter", "drug", keepref=TRUE)
emr_extract(my.track.expression, filter="drug_filter", keepref=TRUE)
\end{verbatim}

\section{Advanced Naryn}

\subsection{Random Algorithms}
Various functions in the library such as \texttt{emr\_quantiles} make use of pseudo-random number generator. Each time the function is invoked a unique series of random numbers is issued. Hence two identical calls might produce different results. To guarantee reproducible results call \texttt{set.seed} before invoking the function.

\subsection{Multitasking}

To boost the run time performance various functions in the library support multitasking mode, i.e. parallel computation by several concurrent processes. Multitasking is not invoked immediately: approximately 0.3 seconds from the function launch the actual progress is measured and total run-time is estimated. If the estimated run-time exceeds the limit (currently: 2 seconds), multitasking kicks in.

The number of processes launched in the multitasking mode depends on the total run-time estimation (longer run-time will use more processes) and the values of \texttt{emr\_min.processes} and \texttt{emr\_max.processes} R options. In any case the number of processes never exceeds the number of CPU cores available.

Multitasking can significantly boost the performance however it utilizes more CPU. When CPU utilization is the priority it is advisable to switch off multitasking by setting \texttt{emr\_multitasking} R option to \texttt{FALSE}.

In addition to increased CPU usage multitasking might also alter the behavior of functions that return ID-Time points such as \texttt{emr\_extract} and \texttt{emr\_screen}. When multitasking is not invoked these functions return the results always sorted by ID, time and reference. In multitasking mode however the result might come out unsorted. Moreover subsequent calls might return results reshuffled differently. One might use \texttt{sort} parameter in these functions to ensure the points come out sorted. Please bear in mind that sorting the results takes its toll especially on particularly large data frames. That's why by default \texttt{sort} is set to \texttt{FALSE}.

\section{Appendix}

\subsection{Options}

Naryn supports the following options (see: \texttt{options} and \texttt{getOption}).
\subparagraph*{}

\begin{tabular}{|l|l|p{3.5in}|}
  \hline
  Option & Default Value & Description \\
  \hline
  \texttt{emr\_multitasking} & \texttt{TRUE} & Should the multitasking be allowed? \\
  & & \\
  \texttt{emr\_min.processes} & \texttt{8} & Minimal number of processes launched when multitasking is invoked. \\
  \texttt{emr\_max.processes} & \texttt{20} & Maximal number of processes launched when multitasking is invoked. \\
  & & \\
  \texttt{emr\_max.data.size} & \texttt{10000000} & Maximal size of data sets (rows of a data frame, length of a vector, ...) stored in memory. Prevents excessive memory usage. \\
  & & \\
  \texttt{emr\_eval.buf.size} & \texttt{1000} & Size of the track expression evaluation buffer.  \\
  & & \\
  \texttt{emr\_warning.itr.no.filter.size} & \texttt{100000} & Threshold above which "beat iterator used without filter" warning is issued.  \\
\hline
\end{tabular}


\subsection{Common Table Formats}

\subsection{Id-Time Points Table}

Id-Time Points table is a data frame having two first columns named ``id'' and ``time''. References might be specified by a third column named ``ref''. If ``ref'' column is missing or named differently references are set to \texttt{-1}. Additional columns if presented are ignored.

\subsection{Ids Table}

Ids table is a data frame having the first column named 'id'. Each id must appear only once. Additional columns of the data frame if presented are ignored.

\subsection{Time Intervals Table}

Time Intervals table is a data frame having two first columns named 'stime' and 'etime' (i.e. start time and end time). Additional columns if presented are ignored.

\subsection{Id-Time Intervals Table}

Id-Time Intervals table is a data frame having three first columns named 'id', 'stime' and 'etime' (i.e. start time and end time). Additional columns if presented are ignored.

\end{document}